{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"themes/Hingle/source/static/hingle.css","path":"static/hingle.css","modified":0,"renderable":1},{"_id":"themes/Hingle/source/static/hingle.js","path":"static/hingle.js","modified":0,"renderable":1},{"_id":"themes/Hingle/source/static/kico.css","path":"static/kico.css","modified":0,"renderable":1},{"_id":"themes/Hingle/source/static/kico.js","path":"static/kico.js","modified":0,"renderable":1},{"_id":"themes/Hingle/source/static/img/icon.png","path":"static/img/icon.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"453d9b293bac00ffeb7acf76c5d5dfc8bebf2708","modified":1704708842382},{"_id":"themes/Hingle/.gitignore","hash":"1e51bee1ec3527ff3e2d6818a5367b5d81c69038","modified":1704709365332},{"_id":"themes/Hingle/LICENSE","hash":"4de1840f7346984f481500155ab438f0fdd12634","modified":1704709365332},{"_id":"themes/Hingle/README.md","hash":"71d1762328de3b6eb7c0536c2d414e8221be0742","modified":1704709365332},{"_id":"themes/Hingle/_config.example.yml","hash":"30d71a66ef8d1ea2ee8e531bc9289f73ce899764","modified":1704709365332},{"_id":"themes/Hingle/_config.yml","hash":"d7531b23ba0788441390d20db44c850efcab2a3d","modified":1704710599246},{"_id":"themes/Hingle/layout/archive.ejs","hash":"90eff02318b17c6eff80021d9a32c2a680415d29","modified":1704709365332},{"_id":"themes/Hingle/layout/index.ejs","hash":"9bcb0ddbe47e19149c6b50b0dc669955d7804caa","modified":1704709365332},{"_id":"themes/Hingle/layout/layout.ejs","hash":"6b51c9598139016d4a451cd32ca9076c3a9089d7","modified":1704709365332},{"_id":"themes/Hingle/layout/page.ejs","hash":"c0cb64ef3215a041c077d91adc911b2f8380c6c1","modified":1704709365332},{"_id":"themes/Hingle/layout/post.ejs","hash":"69cae3890cb41aef16b4bb80ac1b135afa6ca9e8","modified":1704709365332},{"_id":"themes/Hingle/layout/_partial/archive-list.ejs","hash":"d0ff1db7c10c68230f4ee8f7052bf68aa1301f13","modified":1704709365332},{"_id":"themes/Hingle/layout/_partial/footer.ejs","hash":"a8c3df304817e18fa91f12654cdab6e088021469","modified":1704709365332},{"_id":"themes/Hingle/layout/_partial/head.ejs","hash":"3e83286f7fdb7c321e17147b11f9cb04dc4f68f9","modified":1704709365332},{"_id":"themes/Hingle/layout/_partial/header.ejs","hash":"2f13227159607016a577345c974c80fe397666e5","modified":1704709365332},{"_id":"themes/Hingle/layout/_partial/social.ejs","hash":"dc4e3e915327d500b5ad125c0f4847fffb37d47e","modified":1704709365332},{"_id":"themes/Hingle/source/static/hingle.css","hash":"714f235e6706d1f085d4f1e2576f9d8c1a79684e","modified":1704709365332},{"_id":"themes/Hingle/source/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1704709365332},{"_id":"themes/Hingle/source/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1704709365332},{"_id":"themes/Hingle/source/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1704709365332},{"_id":"themes/Hingle/source/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1704709365332},{"_id":"public/2024/01/08/hello-world/index.html","hash":"61b41900ae0ffb1deed634ef7d527def482ba3b9","modified":1704710631969},{"_id":"public/archives/index.html","hash":"d88510ea58b83b79f88390619fe5eed35be58122","modified":1704713107911},{"_id":"public/archives/2024/index.html","hash":"cc77031c9bf551b9bfe3d62f8ddf8cff52a3572c","modified":1704713107911},{"_id":"public/archives/2024/01/index.html","hash":"ae3ea245a6aebc81da777804b009dd431a70e85f","modified":1704713107911},{"_id":"public/index.html","hash":"4833244b868e18f146aa5e8475356f6bbd44cfe7","modified":1704713107911},{"_id":"public/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1704710631969},{"_id":"public/static/hingle.css","hash":"714f235e6706d1f085d4f1e2576f9d8c1a79684e","modified":1704710631969},{"_id":"public/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1704710631969},{"_id":"public/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1704710631969},{"_id":"public/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1704710631969},{"_id":"source/_posts/0001.md","hash":"926d5edc2bce2ad2339e922393e8cd41704cfd0f","modified":1704712357254},{"_id":"source/_posts/0003.md","hash":"9d9c70ab3cf6b5544127e71a4f197d28b0ea6f45","modified":1704712467656},{"_id":"source/_posts/0002.md","hash":"db0c464f1511d8671ea5d05739b7052a35035182","modified":1704712411260},{"_id":"source/_posts/0008.md","hash":"f9410098d9f5a07f15aecfa716abbdcb257e0c29","modified":1704712777080},{"_id":"source/_posts/0007.md","hash":"eedeba92b68d9a9f05d56cf8a6d9ed19ee36ad19","modified":1704712699806},{"_id":"source/_posts/0004.md","hash":"5c6a424d878826418c3b2eb4c5dcef0324d34268","modified":1704712506847},{"_id":"source/_posts/0006.md","hash":"9ac4ce3a4122464be1beb8c0f00d55e854c7e295","modified":1704712584591},{"_id":"source/_posts/0005.md","hash":"472faa06ee01f8b716a6e8d453376da048644fe8","modified":1704712550579},{"_id":"source/_posts/0009.md","hash":"d18fa1832cac2d14209a52bdaaefafb0c08b9d94","modified":1704712828866},{"_id":"source/_posts/0010.md","hash":"097c97dc6f8821406a8a8c64b1317061766ff81e","modified":1704712866007},{"_id":"public/2024/01/03/0008/index.html","hash":"b8d9fb9d1407387666770b45b0d3fc7ed91da0a9","modified":1704713107911},{"_id":"public/2024/01/03/0010/index.html","hash":"b3381c2bf0e6fc4ea7cdd7f878672d3947d00984","modified":1704713107911},{"_id":"public/2023/08/23/0009/index.html","hash":"bae46d5c6b178f33433678e7664199ff7e6d205a","modified":1704713107911},{"_id":"public/2023/07/28/0002/index.html","hash":"ba22c501a9ee692cb88bcde35738bf9a360c51ce","modified":1704713107911},{"_id":"public/2023/07/21/0004/index.html","hash":"d8e89dc660f9c087cdf02eff5746da9297e3ef5d","modified":1704713107911},{"_id":"public/2023/07/08/0005/index.html","hash":"56cb04c064e6d94fb5ee96c231728960d9adce06","modified":1704713107911},{"_id":"public/2023/05/26/0001/index.html","hash":"83d9f53b6cbb8a535eca0a2c3e717b7f32d23912","modified":1704713107911},{"_id":"public/2023/05/26/0006/index.html","hash":"673d95b791e46941c62ff16a32f958ad133d9531","modified":1704713107911},{"_id":"public/2023/03/16/0003/index.html","hash":"fb841e28b3474f2da0cf24d0a96e8b489957ccbf","modified":1704713107911},{"_id":"public/tags/数据结构/index.html","hash":"4075e8ac862147881becda31f51a4431c8805200","modified":1704713107911},{"_id":"public/tags/并查集/index.html","hash":"f9ef5687059fd3cb082e810dbe396bb70a1648f0","modified":1704713107911},{"_id":"public/tags/OI/index.html","hash":"91b708be4e0ae32826d2353004b792895db1f7cb","modified":1704713107911},{"_id":"public/tags/树形结构/index.html","hash":"37ee642ff4c4c550e407d3eedfa0312df794456f","modified":1704713107911},{"_id":"public/tags/分治/index.html","hash":"101a1a002d61f3ee8020c8c9e8a5da13a91df5d8","modified":1704713107911},{"_id":"public/tags/多项式/index.html","hash":"8c1c967f24777b641d058bb45f49d4096e346aa6","modified":1704713107911},{"_id":"public/tags/NOI-Linux/index.html","hash":"4cca7d2429ccc253c7a56ce1f12cb97cab3aafbf","modified":1704713107911},{"_id":"public/tags/网络流/index.html","hash":"f232b1a83531c9165c75be6d5b5c387cf2a14c2b","modified":1704713107911},{"_id":"public/tags/Nvim/index.html","hash":"1ad6c74a87909caad03969d0e0bfc1e6dbb30612","modified":1704713107911},{"_id":"public/tags/IDE/index.html","hash":"f93425cc6947f0d2773c412b5348d20061c5ab6f","modified":1704713107911},{"_id":"public/archives/2023/index.html","hash":"cefeaec76d88dcde847798fb000214748a265bef","modified":1704713107911},{"_id":"public/archives/2023/03/index.html","hash":"f495a2b6773ea39a1ef4490f34b4ee52cc91f9f2","modified":1704713107911},{"_id":"public/archives/2023/05/index.html","hash":"9c36288b6472423b6f992f3fd90d0107eadaf974","modified":1704713107911},{"_id":"public/archives/2023/07/index.html","hash":"504c9360750345d36843b99219cb7427e6e601f3","modified":1704713107911},{"_id":"public/archives/2023/08/index.html","hash":"a71679a309cc8e28a2b128582cdd52e39a02a985","modified":1704713107911},{"_id":"public/2024/01/03/0007/index.html","hash":"1140c2549cade2ab3ca939c7df0293760de2e30f","modified":1704713107911}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"并查集总结","date":"2023-05-25T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# 基础\n\n## 思路\n\n并查集需要高效的处理集合的合并和查询。用线性的数据结构比如数组或者链表存储会导致时间复杂度很高，所以用图或树来存储。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n考虑把所有的元素都存储在一棵树里面，合并集合只用把两棵树合并在一起，接下来考虑如何查询。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n树上每个元素都可以一直向上遍历直到根节点，所以定义一个集合的代表元是这个集合所在的树的根节点，查询两个数是否在一个集合的时候直接比较代表元即可，因为只涉及到找父亲节点的操作，只用记录每个节点的直接父亲。\n\n封装形式：\n\n```cpp\n#define MAXN 100000\nclass node{\n    public:\n        void Union(int x,int y){\n            int fx=getfa(x);\n            int fy=getfa(y);\n            fa[fx]=fy;\n            return ;\n        }\n        bool query(int x,int y){\n            return getfa(x)==getfa(y);\n        }\n        node(int n){\n            for(int i=1;i<=n;i++){\n                fa[i]=i;\n            }\n        }\n    private:\n        int getfa(int x){\n            return x==fa[x]?x:getfa(fa[x]);\n        }\n        int fa[MAXN+5];\n};\n```\n\n上述算法时间复杂度依赖于树高，最坏时间复杂度可能达到 $\\mathcal{O}(n)$，所以要优化。\n\n# 优化\n\n## 启发式合并\n\n其实就是把较小的集合的子树合并到较大的集合的子树中。\n\n## 路径压缩\n\n每次求父亲回溯的时候，把他的直接父亲赋值为代表元，减小树高。\n\n优化后封装代码：\n\n```cpp\n#define MAXN 100000\nclass node{\n    public:\n        void Union(int x,int y){\n            int fx=getfa(x);\n            int fy=getfa(y);\n            if(siz[fx]>siz[fy]){\n                std::swap(fx,fy);\n            }\n            fa[fx]=fy;\n            return ;\n        }\n        bool query(int x,int y){\n            return getfa(x)==getfa(y);\n        }\n        node(int n){\n            for(int i=1;i<=n;i++){\n                fa[i]=i;\n                siz[i]=1;\n            }\n        }\n    private:\n        int getfa(int x){\n            return x==fa[x]?x:fa[x]=getfa(fa[x]);\n        }\n        int fa[MAXN+5];\n        int siz[MAXN+5];\n};\n```\n\n# 扩展\n\n## 敌对并查集\n\n并查集所维护的是朋友的朋友是朋友的一种传递关系。\n\n也可以维护敌人的敌人是朋友的关系。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n对于每个要维护的值 $n$，假设两种元素 $A(n)$ ， $B(n)$，\n$A(n)$用来表示元素本身， $B(n)$则用来表示这个元素的敌人。\n\n$n$ 和 $m$ 是敌人的话，直接合并 $A(n)$和 $B(m)$ 以及 $A(m)$和 $B(n)$。 \n\n$n$ 和 $m$ 是朋友的话，直接合并 $A(n)$和 $A(m)$ 以及 $B(m)$和 $B(n)$。 \n\n同样的，也可以维护有三种阵营的情况，每个值三种元素即可，详细略。\n\n## 树边维护信息\n\n并查集的结构是森林，所以树边可以带权值，路径压缩的时候直接根据定义合并边就行了。\n\n","source":"_posts/0001.md","raw":"---\ntitle: 并查集总结\ndate: 2023-05-26\ntags: [数据结构,并查集,OI]\ntoc: true\nmathjax: true\n---\n\n# 基础\n\n## 思路\n\n并查集需要高效的处理集合的合并和查询。用线性的数据结构比如数组或者链表存储会导致时间复杂度很高，所以用图或树来存储。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n考虑把所有的元素都存储在一棵树里面，合并集合只用把两棵树合并在一起，接下来考虑如何查询。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n树上每个元素都可以一直向上遍历直到根节点，所以定义一个集合的代表元是这个集合所在的树的根节点，查询两个数是否在一个集合的时候直接比较代表元即可，因为只涉及到找父亲节点的操作，只用记录每个节点的直接父亲。\n\n封装形式：\n\n```cpp\n#define MAXN 100000\nclass node{\n    public:\n        void Union(int x,int y){\n            int fx=getfa(x);\n            int fy=getfa(y);\n            fa[fx]=fy;\n            return ;\n        }\n        bool query(int x,int y){\n            return getfa(x)==getfa(y);\n        }\n        node(int n){\n            for(int i=1;i<=n;i++){\n                fa[i]=i;\n            }\n        }\n    private:\n        int getfa(int x){\n            return x==fa[x]?x:getfa(fa[x]);\n        }\n        int fa[MAXN+5];\n};\n```\n\n上述算法时间复杂度依赖于树高，最坏时间复杂度可能达到 $\\mathcal{O}(n)$，所以要优化。\n\n# 优化\n\n## 启发式合并\n\n其实就是把较小的集合的子树合并到较大的集合的子树中。\n\n## 路径压缩\n\n每次求父亲回溯的时候，把他的直接父亲赋值为代表元，减小树高。\n\n优化后封装代码：\n\n```cpp\n#define MAXN 100000\nclass node{\n    public:\n        void Union(int x,int y){\n            int fx=getfa(x);\n            int fy=getfa(y);\n            if(siz[fx]>siz[fy]){\n                std::swap(fx,fy);\n            }\n            fa[fx]=fy;\n            return ;\n        }\n        bool query(int x,int y){\n            return getfa(x)==getfa(y);\n        }\n        node(int n){\n            for(int i=1;i<=n;i++){\n                fa[i]=i;\n                siz[i]=1;\n            }\n        }\n    private:\n        int getfa(int x){\n            return x==fa[x]?x:fa[x]=getfa(fa[x]);\n        }\n        int fa[MAXN+5];\n        int siz[MAXN+5];\n};\n```\n\n# 扩展\n\n## 敌对并查集\n\n并查集所维护的是朋友的朋友是朋友的一种传递关系。\n\n也可以维护敌人的敌人是朋友的关系。\n\n<div STYLE=\"page-break-after:always;s\"></div>\n\n对于每个要维护的值 $n$，假设两种元素 $A(n)$ ， $B(n)$，\n$A(n)$用来表示元素本身， $B(n)$则用来表示这个元素的敌人。\n\n$n$ 和 $m$ 是敌人的话，直接合并 $A(n)$和 $B(m)$ 以及 $A(m)$和 $B(n)$。 \n\n$n$ 和 $m$ 是朋友的话，直接合并 $A(n)$和 $A(m)$ 以及 $B(m)$和 $B(n)$。 \n\n同样的，也可以维护有三种阵营的情况，每个值三种元素即可，详细略。\n\n## 树边维护信息\n\n并查集的结构是森林，所以树边可以带权值，路径压缩的时候直接根据定义合并边就行了。\n\n","slug":"0001","published":1,"updated":"2024-01-08T11:12:37.254Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65ps0000rqay1rcb8b79","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>并查集需要高效的处理集合的合并和查询。用线性的数据结构比如数组或者链表存储会导致时间复杂度很高，所以用图或树来存储。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>考虑把所有的元素都存储在一棵树里面，合并集合只用把两棵树合并在一起，接下来考虑如何查询。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>树上每个元素都可以一直向上遍历直到根节点，所以定义一个集合的代表元是这个集合所在的树的根节点，查询两个数是否在一个集合的时候直接比较代表元即可，因为只涉及到找父亲节点的操作，只用记录每个节点的直接父亲。</p>\n<p>封装形式：</p>\n<pre><code class=\"lang-cpp\">#define MAXN 100000\nclass node&#123;\n    public:\n        void Union(int x,int y)&#123;\n            int fx=getfa(x);\n            int fy=getfa(y);\n            fa[fx]=fy;\n            return ;\n        &#125;\n        bool query(int x,int y)&#123;\n            return getfa(x)==getfa(y);\n        &#125;\n        node(int n)&#123;\n            for(int i=1;i&lt;=n;i++)&#123;\n                fa[i]=i;\n            &#125;\n        &#125;\n    private:\n        int getfa(int x)&#123;\n            return x==fa[x]?x:getfa(fa[x]);\n        &#125;\n        int fa[MAXN+5];\n&#125;;\n</code></pre>\n<p>上述算法时间复杂度依赖于树高，最坏时间复杂度可能达到 $\\mathcal{O}(n)$，所以要优化。</p>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><h2 id=\"启发式合并\"><a href=\"#启发式合并\" class=\"headerlink\" title=\"启发式合并\"></a>启发式合并</h2><p>其实就是把较小的集合的子树合并到较大的集合的子树中。</p>\n<h2 id=\"路径压缩\"><a href=\"#路径压缩\" class=\"headerlink\" title=\"路径压缩\"></a>路径压缩</h2><p>每次求父亲回溯的时候，把他的直接父亲赋值为代表元，减小树高。</p>\n<p>优化后封装代码：</p>\n<pre><code class=\"lang-cpp\">#define MAXN 100000\nclass node&#123;\n    public:\n        void Union(int x,int y)&#123;\n            int fx=getfa(x);\n            int fy=getfa(y);\n            if(siz[fx]&gt;siz[fy])&#123;\n                std::swap(fx,fy);\n            &#125;\n            fa[fx]=fy;\n            return ;\n        &#125;\n        bool query(int x,int y)&#123;\n            return getfa(x)==getfa(y);\n        &#125;\n        node(int n)&#123;\n            for(int i=1;i&lt;=n;i++)&#123;\n                fa[i]=i;\n                siz[i]=1;\n            &#125;\n        &#125;\n    private:\n        int getfa(int x)&#123;\n            return x==fa[x]?x:fa[x]=getfa(fa[x]);\n        &#125;\n        int fa[MAXN+5];\n        int siz[MAXN+5];\n&#125;;\n</code></pre>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h2 id=\"敌对并查集\"><a href=\"#敌对并查集\" class=\"headerlink\" title=\"敌对并查集\"></a>敌对并查集</h2><p>并查集所维护的是朋友的朋友是朋友的一种传递关系。</p>\n<p>也可以维护敌人的敌人是朋友的关系。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>对于每个要维护的值 $n$，假设两种元素 $A(n)$ ， $B(n)$，<br>$A(n)$用来表示元素本身， $B(n)$则用来表示这个元素的敌人。</p>\n<p>$n$ 和 $m$ 是敌人的话，直接合并 $A(n)$和 $B(m)$ 以及 $A(m)$和 $B(n)$。 </p>\n<p>$n$ 和 $m$ 是朋友的话，直接合并 $A(n)$和 $A(m)$ 以及 $B(m)$和 $B(n)$。 </p>\n<p>同样的，也可以维护有三种阵营的情况，每个值三种元素即可，详细略。</p>\n<h2 id=\"树边维护信息\"><a href=\"#树边维护信息\" class=\"headerlink\" title=\"树边维护信息\"></a>树边维护信息</h2><p>并查集的结构是森林，所以树边可以带权值，路径压缩的时候直接根据定义合并边就行了。</p>\n","excerpt":"","more":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>并查集需要高效的处理集合的合并和查询。用线性的数据结构比如数组或者链表存储会导致时间复杂度很高，所以用图或树来存储。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>考虑把所有的元素都存储在一棵树里面，合并集合只用把两棵树合并在一起，接下来考虑如何查询。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>树上每个元素都可以一直向上遍历直到根节点，所以定义一个集合的代表元是这个集合所在的树的根节点，查询两个数是否在一个集合的时候直接比较代表元即可，因为只涉及到找父亲节点的操作，只用记录每个节点的直接父亲。</p>\n<p>封装形式：</p>\n<pre><code class=\"lang-cpp\">#define MAXN 100000\nclass node&#123;\n    public:\n        void Union(int x,int y)&#123;\n            int fx=getfa(x);\n            int fy=getfa(y);\n            fa[fx]=fy;\n            return ;\n        &#125;\n        bool query(int x,int y)&#123;\n            return getfa(x)==getfa(y);\n        &#125;\n        node(int n)&#123;\n            for(int i=1;i&lt;=n;i++)&#123;\n                fa[i]=i;\n            &#125;\n        &#125;\n    private:\n        int getfa(int x)&#123;\n            return x==fa[x]?x:getfa(fa[x]);\n        &#125;\n        int fa[MAXN+5];\n&#125;;\n</code></pre>\n<p>上述算法时间复杂度依赖于树高，最坏时间复杂度可能达到 $\\mathcal{O}(n)$，所以要优化。</p>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><h2 id=\"启发式合并\"><a href=\"#启发式合并\" class=\"headerlink\" title=\"启发式合并\"></a>启发式合并</h2><p>其实就是把较小的集合的子树合并到较大的集合的子树中。</p>\n<h2 id=\"路径压缩\"><a href=\"#路径压缩\" class=\"headerlink\" title=\"路径压缩\"></a>路径压缩</h2><p>每次求父亲回溯的时候，把他的直接父亲赋值为代表元，减小树高。</p>\n<p>优化后封装代码：</p>\n<pre><code class=\"lang-cpp\">#define MAXN 100000\nclass node&#123;\n    public:\n        void Union(int x,int y)&#123;\n            int fx=getfa(x);\n            int fy=getfa(y);\n            if(siz[fx]&gt;siz[fy])&#123;\n                std::swap(fx,fy);\n            &#125;\n            fa[fx]=fy;\n            return ;\n        &#125;\n        bool query(int x,int y)&#123;\n            return getfa(x)==getfa(y);\n        &#125;\n        node(int n)&#123;\n            for(int i=1;i&lt;=n;i++)&#123;\n                fa[i]=i;\n                siz[i]=1;\n            &#125;\n        &#125;\n    private:\n        int getfa(int x)&#123;\n            return x==fa[x]?x:fa[x]=getfa(fa[x]);\n        &#125;\n        int fa[MAXN+5];\n        int siz[MAXN+5];\n&#125;;\n</code></pre>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h2 id=\"敌对并查集\"><a href=\"#敌对并查集\" class=\"headerlink\" title=\"敌对并查集\"></a>敌对并查集</h2><p>并查集所维护的是朋友的朋友是朋友的一种传递关系。</p>\n<p>也可以维护敌人的敌人是朋友的关系。</p>\n<div STYLE=\"page-break-after:always;s\"></div>\n\n<p>对于每个要维护的值 $n$，假设两种元素 $A(n)$ ， $B(n)$，<br>$A(n)$用来表示元素本身， $B(n)$则用来表示这个元素的敌人。</p>\n<p>$n$ 和 $m$ 是敌人的话，直接合并 $A(n)$和 $B(m)$ 以及 $A(m)$和 $B(n)$。 </p>\n<p>$n$ 和 $m$ 是朋友的话，直接合并 $A(n)$和 $A(m)$ 以及 $B(m)$和 $B(n)$。 </p>\n<p>同样的，也可以维护有三种阵营的情况，每个值三种元素即可，详细略。</p>\n<h2 id=\"树边维护信息\"><a href=\"#树边维护信息\" class=\"headerlink\" title=\"树边维护信息\"></a>树边维护信息</h2><p>并查集的结构是森林，所以树边可以带权值，路径压缩的时候直接根据定义合并边就行了。</p>\n"},{"title":"点分治&边分治","date":"2023-07-27T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# 点分治&边分治\n\n## 点分治\n\n### 引入\n\n[P3806](https://www.luogu.com.cn/problem/P3806)\n\n题意：给定一颗具有 $n$ 个节点的树，边上有权值，一共给定 $m$ 次询问，每次询问给定 $k$，要求求出树上距离为 $k$ 的点对是否存在。\n\n树上任意两点的路径是可以分为两条从一个节点到其某个祖先节点的路径。考虑递归到节点 $i$ ，对于此节点，为了进行统计，可以划分为两个部分，一种是经过 $i$ 号节点，另一种是没有经过 $i$ 号节点，很明显没有经过 $i$ 号节点的路径一定在 $i$ 号节点某个儿子的子树内，可以进行递归处理，接下来考虑如何处理，很明显经过 $i$ 号节点的路径一定是经过两个儿子的，定义 $dis_b$ 表示 $b$ 号节点到 $i$ 的距离，很明显这是一条树上从一个节点到其某个祖先节点的路径，我们要找的是二元组 $(a,b)$ ，使得有 $dis_a + dis_b =k $ ，这样直接处理是 $O(n^2)$ ，但是可以开数组 $tf_b$ 表示是否存在 $v$ 使得 $dis_v=b$ 。\n\n### 时间复杂度分析\n\n很明显每一层递归，设以 $i$ 节点为根的子树大小为 $siz_i$ ，很明显每次递归是 $O(siz_i \\times k)$ ，总时间复杂度不难得出，设树深度为 $h$ ，则时间复杂度为 $O(nhk)$ 。\n\n这个时间复杂度依赖于数据，深度最坏可能达到 $n$ ，于是最坏时间复杂度变成了 $O(n^2k)$。\n\n所以是否可以适当变换树的结构使得深度可以减小到 $log_n$ 呢？\n\n### 引入重心\n\n#### 定义\n\n$log$ 的时间复杂度关键在于分成一半，如果可以在递归过程中更换一个根节点，即可，因为这样更改根节点实际上只是更改了一条边，也就是从原来的根节点到他的父亲的边，所以子树内点间距离不会改变，所以怎么选呢？分成一半，在于相等，如果能确保所有儿子的子树大小尽可能相等，即可，换句话说也就是子树大小的最大值最小，注意这里讨论无向边，可以理解为以这个节点作为根节点的时候，求出一个 $W_i$ 是 $\\max(siz_j)~{j\\in son_i}$ ，求出最小的 $W_i$ ，这个点即为重心。\n\n$mss(u)$ 表示 $u$ 的最大子树大小。\n\n形式化的说，找到一个 $u$ 使得 $mss(u)$ 最小。\n\n#### 性质\n\n##### 引理1：\n\n###### 结论：\n\n某个树的重心一定满足他的最大子树大小不大于整棵树的一半，反命题同样成立。\n\n###### 论证：\n\n充分性：\n\n$siz_u(v)$ 表示以 $u$ 为根，$v$ 子树大小。\n\n$mss(u)$ 表示 $u$ 的最大子树大小。\n\n反证法证明，$u$ 为树的重心，假设存在与他相邻的一个节点 $v$ 满足 $siz_u(v)>\\frac n 2$ ，于是有 $siz_v(u)=n-siz_u(v)< \\frac n 2 $ ，于是 $siz_v(u) <siz_u(v) =mss(u)$ ，因为 $siz_u(v)=1+\\sum siz_v(w) ~(w\\in son_v)$，所以有 $siz_v(w)<siz_u(v) ~ (w\\in son_v)$ ,\n\n推出 $mss(v)<siz_u(v)=mss(u)$ ，与重心定义不符。\n\n 必要性：\n\n如果 $mss(u) < \\frac 2 n$ ，则说明对于每个儿子$v$都存在 $siz_u(v) < \\frac 2 n$ ，于是有 $\\sum siz_v(w) < \\frac 2 n ~(w \\in son_v ~\\&~ w \\neq u )$ ，可以推出$siz_v(w) < \\frac 2 n (w \\in son_v ~~\\&~~ w \\neq u)$。\n\n##### 引理2：\n\n###### 结论：\n\n如果一棵树有两个重心，则这两个重心一定相邻，并且树有偶数个节点，可以被划分为两个大小相等的分支，每个分支各自包含一个重心。\n\n###### 论证：\n\n很明显对于两个重心 $u,v$ 有 $mss(u)=mss(v)$，$u$ 的最大子树肯定包含 $v$ ，假设法证明，假设 $w$ 是 $u$ 的最大子树，则有 $mss(u)=siz_u(w)<siz_v(u)$ ，很明显 $siz_v(u) \\leq mss(v) $ ，则有 $mss(u)<mss(v)$，矛盾。\n\n设 $u$ 到 $v$ 经过 $k$ 个中间节点，于是有 $wss(u)=siz_u(v)=k+mss(v)$，明显有 $k=0$。\n\n因为 $siz_u(v)=siz_v(u)$ ，又因为 $siz_u(v)+siz_v(u)=n$ ，所以 $siz_u(v)=siz_v(u)=\\frac 2 n $ ，结论不证自明。\n\n##### 引理3：\n\n###### 结论：\n\n树至少一个重心，至多有两个重心。\n\n###### 论证：\n\n求重心在做求最小值操作，肯定存在最小值。不可能存在三个重心，因为他们两两相邻，会形成环，树怎么可能有环？\n\n##### 引理4：\n\n###### 结论：\n\n假设树上所有边权为 $1$，则记 $dis_i $ 表示所有节点到 $i$ 号节点的距离和，则重心 $u$ 的 $dis_u$ 最小，反命题成立。\n\n###### 论证：\n\n很明显对于非重心点 $u$ ，有 $wss(v) > \\frac 2 n~ (v \\in son_v) $ ，那向 $v$ 移动会使 $dis$ 减少 $siz_u(v)-(n-siz_u(v)=2siz_u(v)-n>0$ ，结论得证。 \n\n##### 求法：\n\n根据定义以及引理1即可\n\n```cpp\n\n```\n","source":"_posts/0002.md","raw":"---\ntitle: 点分治&边分治\ndate: 2023-07-28\ntags: [OI,树形结构,分治]\ntoc: true\nmathjax: true\n---\n\n# 点分治&边分治\n\n## 点分治\n\n### 引入\n\n[P3806](https://www.luogu.com.cn/problem/P3806)\n\n题意：给定一颗具有 $n$ 个节点的树，边上有权值，一共给定 $m$ 次询问，每次询问给定 $k$，要求求出树上距离为 $k$ 的点对是否存在。\n\n树上任意两点的路径是可以分为两条从一个节点到其某个祖先节点的路径。考虑递归到节点 $i$ ，对于此节点，为了进行统计，可以划分为两个部分，一种是经过 $i$ 号节点，另一种是没有经过 $i$ 号节点，很明显没有经过 $i$ 号节点的路径一定在 $i$ 号节点某个儿子的子树内，可以进行递归处理，接下来考虑如何处理，很明显经过 $i$ 号节点的路径一定是经过两个儿子的，定义 $dis_b$ 表示 $b$ 号节点到 $i$ 的距离，很明显这是一条树上从一个节点到其某个祖先节点的路径，我们要找的是二元组 $(a,b)$ ，使得有 $dis_a + dis_b =k $ ，这样直接处理是 $O(n^2)$ ，但是可以开数组 $tf_b$ 表示是否存在 $v$ 使得 $dis_v=b$ 。\n\n### 时间复杂度分析\n\n很明显每一层递归，设以 $i$ 节点为根的子树大小为 $siz_i$ ，很明显每次递归是 $O(siz_i \\times k)$ ，总时间复杂度不难得出，设树深度为 $h$ ，则时间复杂度为 $O(nhk)$ 。\n\n这个时间复杂度依赖于数据，深度最坏可能达到 $n$ ，于是最坏时间复杂度变成了 $O(n^2k)$。\n\n所以是否可以适当变换树的结构使得深度可以减小到 $log_n$ 呢？\n\n### 引入重心\n\n#### 定义\n\n$log$ 的时间复杂度关键在于分成一半，如果可以在递归过程中更换一个根节点，即可，因为这样更改根节点实际上只是更改了一条边，也就是从原来的根节点到他的父亲的边，所以子树内点间距离不会改变，所以怎么选呢？分成一半，在于相等，如果能确保所有儿子的子树大小尽可能相等，即可，换句话说也就是子树大小的最大值最小，注意这里讨论无向边，可以理解为以这个节点作为根节点的时候，求出一个 $W_i$ 是 $\\max(siz_j)~{j\\in son_i}$ ，求出最小的 $W_i$ ，这个点即为重心。\n\n$mss(u)$ 表示 $u$ 的最大子树大小。\n\n形式化的说，找到一个 $u$ 使得 $mss(u)$ 最小。\n\n#### 性质\n\n##### 引理1：\n\n###### 结论：\n\n某个树的重心一定满足他的最大子树大小不大于整棵树的一半，反命题同样成立。\n\n###### 论证：\n\n充分性：\n\n$siz_u(v)$ 表示以 $u$ 为根，$v$ 子树大小。\n\n$mss(u)$ 表示 $u$ 的最大子树大小。\n\n反证法证明，$u$ 为树的重心，假设存在与他相邻的一个节点 $v$ 满足 $siz_u(v)>\\frac n 2$ ，于是有 $siz_v(u)=n-siz_u(v)< \\frac n 2 $ ，于是 $siz_v(u) <siz_u(v) =mss(u)$ ，因为 $siz_u(v)=1+\\sum siz_v(w) ~(w\\in son_v)$，所以有 $siz_v(w)<siz_u(v) ~ (w\\in son_v)$ ,\n\n推出 $mss(v)<siz_u(v)=mss(u)$ ，与重心定义不符。\n\n 必要性：\n\n如果 $mss(u) < \\frac 2 n$ ，则说明对于每个儿子$v$都存在 $siz_u(v) < \\frac 2 n$ ，于是有 $\\sum siz_v(w) < \\frac 2 n ~(w \\in son_v ~\\&~ w \\neq u )$ ，可以推出$siz_v(w) < \\frac 2 n (w \\in son_v ~~\\&~~ w \\neq u)$。\n\n##### 引理2：\n\n###### 结论：\n\n如果一棵树有两个重心，则这两个重心一定相邻，并且树有偶数个节点，可以被划分为两个大小相等的分支，每个分支各自包含一个重心。\n\n###### 论证：\n\n很明显对于两个重心 $u,v$ 有 $mss(u)=mss(v)$，$u$ 的最大子树肯定包含 $v$ ，假设法证明，假设 $w$ 是 $u$ 的最大子树，则有 $mss(u)=siz_u(w)<siz_v(u)$ ，很明显 $siz_v(u) \\leq mss(v) $ ，则有 $mss(u)<mss(v)$，矛盾。\n\n设 $u$ 到 $v$ 经过 $k$ 个中间节点，于是有 $wss(u)=siz_u(v)=k+mss(v)$，明显有 $k=0$。\n\n因为 $siz_u(v)=siz_v(u)$ ，又因为 $siz_u(v)+siz_v(u)=n$ ，所以 $siz_u(v)=siz_v(u)=\\frac 2 n $ ，结论不证自明。\n\n##### 引理3：\n\n###### 结论：\n\n树至少一个重心，至多有两个重心。\n\n###### 论证：\n\n求重心在做求最小值操作，肯定存在最小值。不可能存在三个重心，因为他们两两相邻，会形成环，树怎么可能有环？\n\n##### 引理4：\n\n###### 结论：\n\n假设树上所有边权为 $1$，则记 $dis_i $ 表示所有节点到 $i$ 号节点的距离和，则重心 $u$ 的 $dis_u$ 最小，反命题成立。\n\n###### 论证：\n\n很明显对于非重心点 $u$ ，有 $wss(v) > \\frac 2 n~ (v \\in son_v) $ ，那向 $v$ 移动会使 $dis$ 减少 $siz_u(v)-(n-siz_u(v)=2siz_u(v)-n>0$ ，结论得证。 \n\n##### 求法：\n\n根据定义以及引理1即可\n\n```cpp\n\n```\n","slug":"0002","published":1,"updated":"2024-01-08T11:13:31.260Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65r20001rqay89mf16r3","content":"<h1 id=\"点分治-amp-边分治\"><a href=\"#点分治-amp-边分治\" class=\"headerlink\" title=\"点分治&amp;边分治\"></a>点分治&amp;边分治</h1><h2 id=\"点分治\"><a href=\"#点分治\" class=\"headerlink\" title=\"点分治\"></a>点分治</h2><h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p><a href=\"https://www.luogu.com.cn/problem/P3806\">P3806</a></p>\n<p>题意：给定一颗具有 $n$ 个节点的树，边上有权值，一共给定 $m$ 次询问，每次询问给定 $k$，要求求出树上距离为 $k$ 的点对是否存在。</p>\n<p>树上任意两点的路径是可以分为两条从一个节点到其某个祖先节点的路径。考虑递归到节点 $i$ ，对于此节点，为了进行统计，可以划分为两个部分，一种是经过 $i$ 号节点，另一种是没有经过 $i$ 号节点，很明显没有经过 $i$ 号节点的路径一定在 $i$ 号节点某个儿子的子树内，可以进行递归处理，接下来考虑如何处理，很明显经过 $i$ 号节点的路径一定是经过两个儿子的，定义 $dis_b$ 表示 $b$ 号节点到 $i$ 的距离，很明显这是一条树上从一个节点到其某个祖先节点的路径，我们要找的是二元组 $(a,b)$ ，使得有 $dis_a + dis_b =k $ ，这样直接处理是 $O(n^2)$ ，但是可以开数组 $tf_b$ 表示是否存在 $v$ 使得 $dis_v=b$ 。</p>\n<h3 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h3><p>很明显每一层递归，设以 $i$ 节点为根的子树大小为 $siz_i$ ，很明显每次递归是 $O(siz_i \\times k)$ ，总时间复杂度不难得出，设树深度为 $h$ ，则时间复杂度为 $O(nhk)$ 。</p>\n<p>这个时间复杂度依赖于数据，深度最坏可能达到 $n$ ，于是最坏时间复杂度变成了 $O(n^2k)$。</p>\n<p>所以是否可以适当变换树的结构使得深度可以减小到 $log_n$ 呢？</p>\n<h3 id=\"引入重心\"><a href=\"#引入重心\" class=\"headerlink\" title=\"引入重心\"></a>引入重心</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>$log$ 的时间复杂度关键在于分成一半，如果可以在递归过程中更换一个根节点，即可，因为这样更改根节点实际上只是更改了一条边，也就是从原来的根节点到他的父亲的边，所以子树内点间距离不会改变，所以怎么选呢？分成一半，在于相等，如果能确保所有儿子的子树大小尽可能相等，即可，换句话说也就是子树大小的最大值最小，注意这里讨论无向边，可以理解为以这个节点作为根节点的时候，求出一个 $W_i$ 是 $\\max(siz_j)~{j\\in son_i}$ ，求出最小的 $W_i$ ，这个点即为重心。</p>\n<p>$mss(u)$ 表示 $u$ 的最大子树大小。</p>\n<p>形式化的说，找到一个 $u$ 使得 $mss(u)$ 最小。</p>\n<h4 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h4><h5 id=\"引理1：\"><a href=\"#引理1：\" class=\"headerlink\" title=\"引理1：\"></a>引理1：</h5><h6 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>某个树的重心一定满足他的最大子树大小不大于整棵树的一半，反命题同样成立。</p>\n<h6 id=\"论证：\"><a href=\"#论证：\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>充分性：</p>\n<p>$siz_u(v)$ 表示以 $u$ 为根，$v$ 子树大小。</p>\n<p>$mss(u)$ 表示 $u$ 的最大子树大小。</p>\n<p>反证法证明，$u$ 为树的重心，假设存在与他相邻的一个节点 $v$ 满足 $siz_u(v)&gt;\\frac n 2$ ，于是有 $siz_v(u)=n-siz_u(v)&lt; \\frac n 2 $ ，于是 $siz_v(u) &lt;siz_u(v) =mss(u)$ ，因为 $siz_u(v)=1+\\sum siz_v(w) ~(w\\in son_v)$，所以有 $siz_v(w)&lt;siz_u(v) ~ (w\\in son_v)$ ,</p>\n<p>推出 $mss(v)&lt;siz_u(v)=mss(u)$ ，与重心定义不符。</p>\n<p> 必要性：</p>\n<p>如果 $mss(u) &lt; \\frac 2 n$ ，则说明对于每个儿子$v$都存在 $siz_u(v) &lt; \\frac 2 n$ ，于是有 $\\sum siz_v(w) &lt; \\frac 2 n ~(w \\in son_v ~\\&amp;~ w \\neq u )$ ，可以推出$siz_v(w) &lt; \\frac 2 n (w \\in son_v <del>\\&amp;</del> w \\neq u)$。</p>\n<h5 id=\"引理2：\"><a href=\"#引理2：\" class=\"headerlink\" title=\"引理2：\"></a>引理2：</h5><h6 id=\"结论：-1\"><a href=\"#结论：-1\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>如果一棵树有两个重心，则这两个重心一定相邻，并且树有偶数个节点，可以被划分为两个大小相等的分支，每个分支各自包含一个重心。</p>\n<h6 id=\"论证：-1\"><a href=\"#论证：-1\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>很明显对于两个重心 $u,v$ 有 $mss(u)=mss(v)$，$u$ 的最大子树肯定包含 $v$ ，假设法证明，假设 $w$ 是 $u$ 的最大子树，则有 $mss(u)=siz_u(w)&lt;siz_v(u)$ ，很明显 $siz_v(u) \\leq mss(v) $ ，则有 $mss(u)&lt;mss(v)$，矛盾。</p>\n<p>设 $u$ 到 $v$ 经过 $k$ 个中间节点，于是有 $wss(u)=siz_u(v)=k+mss(v)$，明显有 $k=0$。</p>\n<p>因为 $siz_u(v)=siz_v(u)$ ，又因为 $siz_u(v)+siz_v(u)=n$ ，所以 $siz_u(v)=siz_v(u)=\\frac 2 n $ ，结论不证自明。</p>\n<h5 id=\"引理3：\"><a href=\"#引理3：\" class=\"headerlink\" title=\"引理3：\"></a>引理3：</h5><h6 id=\"结论：-2\"><a href=\"#结论：-2\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>树至少一个重心，至多有两个重心。</p>\n<h6 id=\"论证：-2\"><a href=\"#论证：-2\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>求重心在做求最小值操作，肯定存在最小值。不可能存在三个重心，因为他们两两相邻，会形成环，树怎么可能有环？</p>\n<h5 id=\"引理4：\"><a href=\"#引理4：\" class=\"headerlink\" title=\"引理4：\"></a>引理4：</h5><h6 id=\"结论：-3\"><a href=\"#结论：-3\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>假设树上所有边权为 $1$，则记 $dis_i $ 表示所有节点到 $i$ 号节点的距离和，则重心 $u$ 的 $dis_u$ 最小，反命题成立。</p>\n<h6 id=\"论证：-3\"><a href=\"#论证：-3\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>很明显对于非重心点 $u$ ，有 $wss(v) &gt; \\frac 2 n~ (v \\in son_v) $ ，那向 $v$ 移动会使 $dis$ 减少 $siz_u(v)-(n-siz_u(v)=2siz_u(v)-n&gt;0$ ，结论得证。 </p>\n<h5 id=\"求法：\"><a href=\"#求法：\" class=\"headerlink\" title=\"求法：\"></a>求法：</h5><p>根据定义以及引理1即可</p>\n<pre><code class=\"lang-cpp\">\n\n</code></pre>\n","excerpt":"","more":"<h1 id=\"点分治-amp-边分治\"><a href=\"#点分治-amp-边分治\" class=\"headerlink\" title=\"点分治&amp;边分治\"></a>点分治&amp;边分治</h1><h2 id=\"点分治\"><a href=\"#点分治\" class=\"headerlink\" title=\"点分治\"></a>点分治</h2><h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p><a href=\"https://www.luogu.com.cn/problem/P3806\">P3806</a></p>\n<p>题意：给定一颗具有 $n$ 个节点的树，边上有权值，一共给定 $m$ 次询问，每次询问给定 $k$，要求求出树上距离为 $k$ 的点对是否存在。</p>\n<p>树上任意两点的路径是可以分为两条从一个节点到其某个祖先节点的路径。考虑递归到节点 $i$ ，对于此节点，为了进行统计，可以划分为两个部分，一种是经过 $i$ 号节点，另一种是没有经过 $i$ 号节点，很明显没有经过 $i$ 号节点的路径一定在 $i$ 号节点某个儿子的子树内，可以进行递归处理，接下来考虑如何处理，很明显经过 $i$ 号节点的路径一定是经过两个儿子的，定义 $dis_b$ 表示 $b$ 号节点到 $i$ 的距离，很明显这是一条树上从一个节点到其某个祖先节点的路径，我们要找的是二元组 $(a,b)$ ，使得有 $dis_a + dis_b =k $ ，这样直接处理是 $O(n^2)$ ，但是可以开数组 $tf_b$ 表示是否存在 $v$ 使得 $dis_v=b$ 。</p>\n<h3 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h3><p>很明显每一层递归，设以 $i$ 节点为根的子树大小为 $siz_i$ ，很明显每次递归是 $O(siz_i \\times k)$ ，总时间复杂度不难得出，设树深度为 $h$ ，则时间复杂度为 $O(nhk)$ 。</p>\n<p>这个时间复杂度依赖于数据，深度最坏可能达到 $n$ ，于是最坏时间复杂度变成了 $O(n^2k)$。</p>\n<p>所以是否可以适当变换树的结构使得深度可以减小到 $log_n$ 呢？</p>\n<h3 id=\"引入重心\"><a href=\"#引入重心\" class=\"headerlink\" title=\"引入重心\"></a>引入重心</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>$log$ 的时间复杂度关键在于分成一半，如果可以在递归过程中更换一个根节点，即可，因为这样更改根节点实际上只是更改了一条边，也就是从原来的根节点到他的父亲的边，所以子树内点间距离不会改变，所以怎么选呢？分成一半，在于相等，如果能确保所有儿子的子树大小尽可能相等，即可，换句话说也就是子树大小的最大值最小，注意这里讨论无向边，可以理解为以这个节点作为根节点的时候，求出一个 $W_i$ 是 $\\max(siz_j)~{j\\in son_i}$ ，求出最小的 $W_i$ ，这个点即为重心。</p>\n<p>$mss(u)$ 表示 $u$ 的最大子树大小。</p>\n<p>形式化的说，找到一个 $u$ 使得 $mss(u)$ 最小。</p>\n<h4 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h4><h5 id=\"引理1：\"><a href=\"#引理1：\" class=\"headerlink\" title=\"引理1：\"></a>引理1：</h5><h6 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>某个树的重心一定满足他的最大子树大小不大于整棵树的一半，反命题同样成立。</p>\n<h6 id=\"论证：\"><a href=\"#论证：\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>充分性：</p>\n<p>$siz_u(v)$ 表示以 $u$ 为根，$v$ 子树大小。</p>\n<p>$mss(u)$ 表示 $u$ 的最大子树大小。</p>\n<p>反证法证明，$u$ 为树的重心，假设存在与他相邻的一个节点 $v$ 满足 $siz_u(v)&gt;\\frac n 2$ ，于是有 $siz_v(u)=n-siz_u(v)&lt; \\frac n 2 $ ，于是 $siz_v(u) &lt;siz_u(v) =mss(u)$ ，因为 $siz_u(v)=1+\\sum siz_v(w) ~(w\\in son_v)$，所以有 $siz_v(w)&lt;siz_u(v) ~ (w\\in son_v)$ ,</p>\n<p>推出 $mss(v)&lt;siz_u(v)=mss(u)$ ，与重心定义不符。</p>\n<p> 必要性：</p>\n<p>如果 $mss(u) &lt; \\frac 2 n$ ，则说明对于每个儿子$v$都存在 $siz_u(v) &lt; \\frac 2 n$ ，于是有 $\\sum siz_v(w) &lt; \\frac 2 n ~(w \\in son_v ~\\&amp;~ w \\neq u )$ ，可以推出$siz_v(w) &lt; \\frac 2 n (w \\in son_v <del>\\&amp;</del> w \\neq u)$。</p>\n<h5 id=\"引理2：\"><a href=\"#引理2：\" class=\"headerlink\" title=\"引理2：\"></a>引理2：</h5><h6 id=\"结论：-1\"><a href=\"#结论：-1\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>如果一棵树有两个重心，则这两个重心一定相邻，并且树有偶数个节点，可以被划分为两个大小相等的分支，每个分支各自包含一个重心。</p>\n<h6 id=\"论证：-1\"><a href=\"#论证：-1\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>很明显对于两个重心 $u,v$ 有 $mss(u)=mss(v)$，$u$ 的最大子树肯定包含 $v$ ，假设法证明，假设 $w$ 是 $u$ 的最大子树，则有 $mss(u)=siz_u(w)&lt;siz_v(u)$ ，很明显 $siz_v(u) \\leq mss(v) $ ，则有 $mss(u)&lt;mss(v)$，矛盾。</p>\n<p>设 $u$ 到 $v$ 经过 $k$ 个中间节点，于是有 $wss(u)=siz_u(v)=k+mss(v)$，明显有 $k=0$。</p>\n<p>因为 $siz_u(v)=siz_v(u)$ ，又因为 $siz_u(v)+siz_v(u)=n$ ，所以 $siz_u(v)=siz_v(u)=\\frac 2 n $ ，结论不证自明。</p>\n<h5 id=\"引理3：\"><a href=\"#引理3：\" class=\"headerlink\" title=\"引理3：\"></a>引理3：</h5><h6 id=\"结论：-2\"><a href=\"#结论：-2\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>树至少一个重心，至多有两个重心。</p>\n<h6 id=\"论证：-2\"><a href=\"#论证：-2\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>求重心在做求最小值操作，肯定存在最小值。不可能存在三个重心，因为他们两两相邻，会形成环，树怎么可能有环？</p>\n<h5 id=\"引理4：\"><a href=\"#引理4：\" class=\"headerlink\" title=\"引理4：\"></a>引理4：</h5><h6 id=\"结论：-3\"><a href=\"#结论：-3\" class=\"headerlink\" title=\"结论：\"></a>结论：</h6><p>假设树上所有边权为 $1$，则记 $dis_i $ 表示所有节点到 $i$ 号节点的距离和，则重心 $u$ 的 $dis_u$ 最小，反命题成立。</p>\n<h6 id=\"论证：-3\"><a href=\"#论证：-3\" class=\"headerlink\" title=\"论证：\"></a>论证：</h6><p>很明显对于非重心点 $u$ ，有 $wss(v) &gt; \\frac 2 n~ (v \\in son_v) $ ，那向 $v$ 移动会使 $dis$ 减少 $siz_u(v)-(n-siz_u(v)=2siz_u(v)-n&gt;0$ ，结论得证。 </p>\n<h5 id=\"求法：\"><a href=\"#求法：\" class=\"headerlink\" title=\"求法：\"></a>求法：</h5><p>根据定义以及引理1即可</p>\n<pre><code class=\"lang-cpp\">\n\n</code></pre>\n"},{"title":"多项式傅里叶变换全家桶","date":"2023-03-15T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n卷积：$h_i=\\sum _{j=0}^{i}f_j \\times g_{i-j}$，其中 $h_i$ 是多项式 $H$ 的 $i$ 次项系数。其实就是多项式乘法。\n\n# FFT（快速傅里叶变换）\n\n## 思想\n\n直接朴素乘会导致太慢了，时间复杂度直逼 $\\mathcal{O}(n^2)$，仍然停留在多项式的系数表达式太浅薄了，可以尝试一下点值表达式。\n\n对于一个有 $n$ 项的多项式，只要取不同的 $n$ 个值即可确定这个多项式，如果直接把两个多项式同时取 $n$ 个值，再把相同 $x$ 值得到的结果相乘，最后转换为系数表达，时间复杂度不会有任何改进，所以可以从取值的方面来下功夫。\n\n## 前置知识\n\n##### 1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。\n\n##### 2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\n\n##### 3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\n\n![](E:\\1.PNG)\n\n##### 3. 虚数的运算：\n\n$~~~~~~~~~$加减法直接把实部和虚部分别相加即可。\n\n\n\n\n$~~~~~~~~~$乘法在代数意义上的运算：$(a+bi)\\times(c+di)$=$ac+adi+bci-bd$=$(ac-bd)+(ad+bc)i$\n\n\n\n\n$~~~~~~~~~$几何意义：幅角相加，模长相乘。\n\n##### 4.单位根\n\n$~~~~~~~~~$定义 $\\omega_n$ 为 $\\omega_n^n=1$，很容易推出其中一个单位根为模长为1，幅角为$360/n$，很容易想到这个数自乘 $n$ 次，旋转 $360$度，与正实轴重合，模长为1，$\\omega_n^k$也满足${(\\omega_n^k)}^n=1$，证明同理。\n\n##### 5.单位根性质\n\n$~~~~~~~~~$ $\\omega_n^k=\\omega_{n/2}^{k/2}$ ，证明：$\\omega_n^k$为模长为1，幅角为$\\frac{360k}{n}$度，$\\omega_{n/2}^{k/2}$也是一样的。\n\n$~~~~~~~~~$ $\\omega_n^{k}=-\\omega_n^{k+n/2}$, 证明：多转了180度，所以就是相反数。\n\n$~~~~~~~~~$ $\\omega_n^0=\\omega_n^n=1$，由定义得。\n\n$~~~~~~~~~$ $\\omega_n^{k}=\\omega_n^{n+k}$，证明：转360度转回来了。\n\n## 正向FFT（系数到点值）\n\n可以代入所有的单位根，为了统一计算，把所有的多项式补全到 $2^k$，其中k是满足 $2^k \\leq n+m+1$的最小值。高次项全部补0即可。\n\n$A(x)=(a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1})$\n\n按照次数奇偶性分组，$A(x)=(a_0+a_2x^2+...+a_{n-2}x^{n-2})+(a_1x+a_3x^3+...+a_{n-1}x^{n-1})$\n\n继续定义 B(x)=a_0+a_2x+a_4x^2+...+a_{n-2}x^{(n-2)/2}$\n\n$C(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^{(n-2)/2}$\n\n则 $A(x)=B(x^2)+xC(x^2)$\n\n将 $\\omega_n^k$ 代入原式得 $A(\\omega_n^k)=B(\\omega_n^{2k})+\\omega_n^kC(\\omega_n^{2k})$，因为相比原式项数减半所以把 $\\omega_n^{2k}$ 化为 $\\omega_{n/2}^k$得 $A(\\omega_n^k)=B(\\omega_{n/2}^k)+\\omega_n^kC(\\omega_{n/2}^k)$\n\n$B,C$递归处理即可。\n\n## IFFT（逆变换）\n\n上面算出来了点值表示法，如何转成系数表达式捏。\n\n设原多项式的点值表达式在 $\\omega_n^k(0 \\leq k<n)$ 得到 $y_0,y_1,...,y_{n-1}$\n\n设多项式 $D(x)=y_0+y_1x+y_2x^2+y_3x^3+...y_{n-1}x^{n-1}$。\n\n设在 $\\omega_n^{-k}(0 \\leq k<n)$的 点值表达式是 $z_0,z_1,...,z_{n-1}$。\n\n可证得$c_k=\\sum_{i=0}^{n-1}a_j(\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i)$\n\n核心的就是$\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i$，设$S(x)=\\sum^{n-1}_{i=0}x^i$\n\n易证 $S(x)=\\frac {1-1}{w_n^k-1}$\n\n当$w_n^k!=1$时，$S(x)=0$\n\n当$w_n^k=1$时，$S(x)=n$\n\n代入得$c_k=na_k$\n\n所以 $a_k=c_k/n$\n\n## 优化\n\n递归实现容易爆栈，而且极其慢，考虑优化为迭代实现。\n\n优化为迭代实现的瓶颈在于如何划分系数，不过可以非常简单的把需要合并在一起的项放在一起。\n\n只有一项的多项式，点值表达式和系数表达式是一样的。\n\n因为上述按奇偶性分开，其实是按照下标二进制表达从后往前来比较的来划分的，相同的会放在一起，所以可以直接按照下表二进制反转的顺序来依次合并。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#define int long long\ninline int read();\nconst double Pi=acos(-1.0);\nstd::complex <double> f[8000005],g[8000005],ans[8000005];\nint r[8000005];\nvoid fft(std::complex <double> *f,int limit,int type);\nsigned main(){\n    int n=read(),m;\n\n    std::complex <double> temp=f[0];\n    m=read();\n    int limit=1,k=0;\n    while(limit<(n+m+2)){\n        limit=(limit)<<1;\n        k++;\n    }\n    for(int i=0;i<=n;i++){\n        f[i]=read();\n    }\n    for(int i=0;i<=m;i++){\n        g[i]=read();\n    }\n    for(int i=0;i<=limit;i++){\n        r[i]=(r[i>>1]>>1)|((i&1)<<(k-1));\n    }\n    fft(f,limit,1);\n    fft(g,limit,1);\n    for(int i=0;i<=limit;i++){\n        f[i]*=g[i];\n    }\n    fft(f,limit,-1);\n    for(int i=0;i<=n+m;i++){\n        printf(\"%lld \",(int)(f[i].real()/(limit)+0.5));\n    }\n    return 0;\n}\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){\n        c=='-'?f=-1:1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<3)+(x<<1)+(c^48);\n        c=getchar();\n    }\n    return f*x;\n}\nvoid fft(std::complex <double> *f,int limit,int type){\n    for(int i=0;i<=limit;i++){\n        if(i<r[i]){\n            swap(f[i],f[r[i]]);\n        }\n    }\n    for(int length=2;length<=limit;length=(length<<1)){\n        std::complex <double> Wn (std::cos(Pi*2/length),std::sin(type*Pi*2/length));\n        for(int i=0;i<=limit;i+=length){\n            std::complex <double> wn1(1,0);\n            for(int k=i;k<length/2+i;k++,wn1=wn1*Wn){\n                std::complex <double> x=f[k],y=f[k+length/2]*wn1;\n                f[k]=x+y;\n                f[k+length/2]=x-y;\n            }\n        }\n    }\n    return ;\n}\n```\n\n# NTT (快速数论变换)\n\n## 思想\n\n因为FFT涉及到复杂的复数运算，不仅很慢，不能取模，甚至有精度问题。\n\n所有如果在取模意义下，也可以用与FFT所利用的的单位根相似的原根。\n\n## 数学知识\n\n原根的定义理所当然，定义一个数 $n$ 的原根为 $g$ ，是满足$g^n \\equiv 1(mod~p)$的最小整数。\n\n原根满足 $g^i(1 \\leq i \\leq n)$ 模 $p$ 两两不同。\n\n一般取模数为 $998244353$ ，其原根是 $3$。\n\n对于代值的数的表示仍然是$\\omega_n$：\n\n$w_n \\equiv g^{\\frac{p-1}{n}} (mod~p)$\n\n$\\omega_n^k=\\omega_{n/2}^{k/2}$ 。\n\n$\\omega_n^{k}=-\\omega_n^{k+n/2}$。\n\n$\\omega_n^0=\\omega_n^n=1$。\n\n$\\omega_n^{k}=\\omega_n^{n+k}$。\n\n## 直接把FFT的代值改成NTT\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define int long long\ninline int read();\nint a[8000005],b[8000005];\nint li=1,k=0;\nint r[8000005];\nconst int mod=998244353;\nconst int g=3;\nconst int g2=332748118;\nvoid print(int x){\n    register char s[20];\n    register int i=0;\n    if(x<0){\n        x=-x;\n        putchar('-');\n    }\n    if(x==0){\n        putchar('0');\n        return;\n    }\n    while(x){\n        s[i++]=x%10;\n        x/=10;\n    }\n    while(i){\n        putchar(s[--i]+'0');\n    }\n    return;\n}\ninline int fast_power(int a, int k) //快速幂，a为底数，k为指数\n{\n    register int res = 1;\n    while (k)\n    {\n        if (k & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        k >>= 1;\n    }\n    return res;\n}\ninline void ntt(int *a,int type){\n    for(register int i=0;i<=li;i++){\n        if(i<r[i]){\n            std::swap(a[i],a[r[i]]);\n        }\n    }\n    int gn;\n    for(register int i=1;i<li;i<<=1){\n        gn=fast_power(type?g:g2,(mod-1)/(i<<1));\n        for(register int j=0;j<li;j+=(i<<1)){\n            int g0=1;\n            for(int k=0;k<i;k++,g0=(g0*gn)%mod){\n                int x=a[j+k];\n                int y=(a[i+j+k]*g0)%mod;\n                a[j+k]=(x+y)%mod;\n                a[i+j+k]=(x-y+mod)%mod;\n            }\n        }\n    }\n    return ;\n}\nsigned main(){\n    #ifdef ONLINE_JUDGE\n    #else\n    // freopen(\".in\",\"r\",stdin);\n    // freopen(\".out\",\"w\",stdout);\n    #endif\n    int n=read(),m=read();\n    for(register int i=0;i<=n;i++){\n        a[i]=read();\n    }\n    for(register int i=0;i<=m;i++){\n        b[i]=read();\n    }\n    while(li<(n+m+2)){\n        li=(li)<<1;\n        k++;\n    }\n    for(register int i=0;i<=li;i++){\n        r[i]=(r[i>>1]>>1)|((i&1)<<(k-1));\n    }\n    ntt(a,1);\n    ntt(b,1);\n    for(register int i=0;i<=li;i++){\n        a[i]*=b[i];\n        a[i]%=mod;\n    }\n    ntt(a,0);\n    long long inv=fast_power(li,mod-2);\n    for(register int i=0;i<=n+m;i++){\n        print((a[i]*inv)%mod);\n        putchar(' ');\n    }\n    return 0;\n}\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){\n        c=='-'?f=-1:1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<3)+(x<<1)+(c^48);\n        c=getchar();\n    }\n    return f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n```\n\n# 扩展题目\n","source":"_posts/0003.md","raw":"---\ntitle: 多项式傅里叶变换全家桶\ndate: 2023-03-16\ntags: [OI,多项式]\ntoc: true\nmathjax: true\n---\n\n卷积：$h_i=\\sum _{j=0}^{i}f_j \\times g_{i-j}$，其中 $h_i$ 是多项式 $H$ 的 $i$ 次项系数。其实就是多项式乘法。\n\n# FFT（快速傅里叶变换）\n\n## 思想\n\n直接朴素乘会导致太慢了，时间复杂度直逼 $\\mathcal{O}(n^2)$，仍然停留在多项式的系数表达式太浅薄了，可以尝试一下点值表达式。\n\n对于一个有 $n$ 项的多项式，只要取不同的 $n$ 个值即可确定这个多项式，如果直接把两个多项式同时取 $n$ 个值，再把相同 $x$ 值得到的结果相乘，最后转换为系数表达，时间复杂度不会有任何改进，所以可以从取值的方面来下功夫。\n\n## 前置知识\n\n##### 1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。\n\n##### 2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\n\n##### 3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\n\n![](E:\\1.PNG)\n\n##### 3. 虚数的运算：\n\n$~~~~~~~~~$加减法直接把实部和虚部分别相加即可。\n\n\n\n\n$~~~~~~~~~$乘法在代数意义上的运算：$(a+bi)\\times(c+di)$=$ac+adi+bci-bd$=$(ac-bd)+(ad+bc)i$\n\n\n\n\n$~~~~~~~~~$几何意义：幅角相加，模长相乘。\n\n##### 4.单位根\n\n$~~~~~~~~~$定义 $\\omega_n$ 为 $\\omega_n^n=1$，很容易推出其中一个单位根为模长为1，幅角为$360/n$，很容易想到这个数自乘 $n$ 次，旋转 $360$度，与正实轴重合，模长为1，$\\omega_n^k$也满足${(\\omega_n^k)}^n=1$，证明同理。\n\n##### 5.单位根性质\n\n$~~~~~~~~~$ $\\omega_n^k=\\omega_{n/2}^{k/2}$ ，证明：$\\omega_n^k$为模长为1，幅角为$\\frac{360k}{n}$度，$\\omega_{n/2}^{k/2}$也是一样的。\n\n$~~~~~~~~~$ $\\omega_n^{k}=-\\omega_n^{k+n/2}$, 证明：多转了180度，所以就是相反数。\n\n$~~~~~~~~~$ $\\omega_n^0=\\omega_n^n=1$，由定义得。\n\n$~~~~~~~~~$ $\\omega_n^{k}=\\omega_n^{n+k}$，证明：转360度转回来了。\n\n## 正向FFT（系数到点值）\n\n可以代入所有的单位根，为了统一计算，把所有的多项式补全到 $2^k$，其中k是满足 $2^k \\leq n+m+1$的最小值。高次项全部补0即可。\n\n$A(x)=(a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1})$\n\n按照次数奇偶性分组，$A(x)=(a_0+a_2x^2+...+a_{n-2}x^{n-2})+(a_1x+a_3x^3+...+a_{n-1}x^{n-1})$\n\n继续定义 B(x)=a_0+a_2x+a_4x^2+...+a_{n-2}x^{(n-2)/2}$\n\n$C(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^{(n-2)/2}$\n\n则 $A(x)=B(x^2)+xC(x^2)$\n\n将 $\\omega_n^k$ 代入原式得 $A(\\omega_n^k)=B(\\omega_n^{2k})+\\omega_n^kC(\\omega_n^{2k})$，因为相比原式项数减半所以把 $\\omega_n^{2k}$ 化为 $\\omega_{n/2}^k$得 $A(\\omega_n^k)=B(\\omega_{n/2}^k)+\\omega_n^kC(\\omega_{n/2}^k)$\n\n$B,C$递归处理即可。\n\n## IFFT（逆变换）\n\n上面算出来了点值表示法，如何转成系数表达式捏。\n\n设原多项式的点值表达式在 $\\omega_n^k(0 \\leq k<n)$ 得到 $y_0,y_1,...,y_{n-1}$\n\n设多项式 $D(x)=y_0+y_1x+y_2x^2+y_3x^3+...y_{n-1}x^{n-1}$。\n\n设在 $\\omega_n^{-k}(0 \\leq k<n)$的 点值表达式是 $z_0,z_1,...,z_{n-1}$。\n\n可证得$c_k=\\sum_{i=0}^{n-1}a_j(\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i)$\n\n核心的就是$\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i$，设$S(x)=\\sum^{n-1}_{i=0}x^i$\n\n易证 $S(x)=\\frac {1-1}{w_n^k-1}$\n\n当$w_n^k!=1$时，$S(x)=0$\n\n当$w_n^k=1$时，$S(x)=n$\n\n代入得$c_k=na_k$\n\n所以 $a_k=c_k/n$\n\n## 优化\n\n递归实现容易爆栈，而且极其慢，考虑优化为迭代实现。\n\n优化为迭代实现的瓶颈在于如何划分系数，不过可以非常简单的把需要合并在一起的项放在一起。\n\n只有一项的多项式，点值表达式和系数表达式是一样的。\n\n因为上述按奇偶性分开，其实是按照下标二进制表达从后往前来比较的来划分的，相同的会放在一起，所以可以直接按照下表二进制反转的顺序来依次合并。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#define int long long\ninline int read();\nconst double Pi=acos(-1.0);\nstd::complex <double> f[8000005],g[8000005],ans[8000005];\nint r[8000005];\nvoid fft(std::complex <double> *f,int limit,int type);\nsigned main(){\n    int n=read(),m;\n\n    std::complex <double> temp=f[0];\n    m=read();\n    int limit=1,k=0;\n    while(limit<(n+m+2)){\n        limit=(limit)<<1;\n        k++;\n    }\n    for(int i=0;i<=n;i++){\n        f[i]=read();\n    }\n    for(int i=0;i<=m;i++){\n        g[i]=read();\n    }\n    for(int i=0;i<=limit;i++){\n        r[i]=(r[i>>1]>>1)|((i&1)<<(k-1));\n    }\n    fft(f,limit,1);\n    fft(g,limit,1);\n    for(int i=0;i<=limit;i++){\n        f[i]*=g[i];\n    }\n    fft(f,limit,-1);\n    for(int i=0;i<=n+m;i++){\n        printf(\"%lld \",(int)(f[i].real()/(limit)+0.5));\n    }\n    return 0;\n}\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){\n        c=='-'?f=-1:1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<3)+(x<<1)+(c^48);\n        c=getchar();\n    }\n    return f*x;\n}\nvoid fft(std::complex <double> *f,int limit,int type){\n    for(int i=0;i<=limit;i++){\n        if(i<r[i]){\n            swap(f[i],f[r[i]]);\n        }\n    }\n    for(int length=2;length<=limit;length=(length<<1)){\n        std::complex <double> Wn (std::cos(Pi*2/length),std::sin(type*Pi*2/length));\n        for(int i=0;i<=limit;i+=length){\n            std::complex <double> wn1(1,0);\n            for(int k=i;k<length/2+i;k++,wn1=wn1*Wn){\n                std::complex <double> x=f[k],y=f[k+length/2]*wn1;\n                f[k]=x+y;\n                f[k+length/2]=x-y;\n            }\n        }\n    }\n    return ;\n}\n```\n\n# NTT (快速数论变换)\n\n## 思想\n\n因为FFT涉及到复杂的复数运算，不仅很慢，不能取模，甚至有精度问题。\n\n所有如果在取模意义下，也可以用与FFT所利用的的单位根相似的原根。\n\n## 数学知识\n\n原根的定义理所当然，定义一个数 $n$ 的原根为 $g$ ，是满足$g^n \\equiv 1(mod~p)$的最小整数。\n\n原根满足 $g^i(1 \\leq i \\leq n)$ 模 $p$ 两两不同。\n\n一般取模数为 $998244353$ ，其原根是 $3$。\n\n对于代值的数的表示仍然是$\\omega_n$：\n\n$w_n \\equiv g^{\\frac{p-1}{n}} (mod~p)$\n\n$\\omega_n^k=\\omega_{n/2}^{k/2}$ 。\n\n$\\omega_n^{k}=-\\omega_n^{k+n/2}$。\n\n$\\omega_n^0=\\omega_n^n=1$。\n\n$\\omega_n^{k}=\\omega_n^{n+k}$。\n\n## 直接把FFT的代值改成NTT\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define int long long\ninline int read();\nint a[8000005],b[8000005];\nint li=1,k=0;\nint r[8000005];\nconst int mod=998244353;\nconst int g=3;\nconst int g2=332748118;\nvoid print(int x){\n    register char s[20];\n    register int i=0;\n    if(x<0){\n        x=-x;\n        putchar('-');\n    }\n    if(x==0){\n        putchar('0');\n        return;\n    }\n    while(x){\n        s[i++]=x%10;\n        x/=10;\n    }\n    while(i){\n        putchar(s[--i]+'0');\n    }\n    return;\n}\ninline int fast_power(int a, int k) //快速幂，a为底数，k为指数\n{\n    register int res = 1;\n    while (k)\n    {\n        if (k & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        k >>= 1;\n    }\n    return res;\n}\ninline void ntt(int *a,int type){\n    for(register int i=0;i<=li;i++){\n        if(i<r[i]){\n            std::swap(a[i],a[r[i]]);\n        }\n    }\n    int gn;\n    for(register int i=1;i<li;i<<=1){\n        gn=fast_power(type?g:g2,(mod-1)/(i<<1));\n        for(register int j=0;j<li;j+=(i<<1)){\n            int g0=1;\n            for(int k=0;k<i;k++,g0=(g0*gn)%mod){\n                int x=a[j+k];\n                int y=(a[i+j+k]*g0)%mod;\n                a[j+k]=(x+y)%mod;\n                a[i+j+k]=(x-y+mod)%mod;\n            }\n        }\n    }\n    return ;\n}\nsigned main(){\n    #ifdef ONLINE_JUDGE\n    #else\n    // freopen(\".in\",\"r\",stdin);\n    // freopen(\".out\",\"w\",stdout);\n    #endif\n    int n=read(),m=read();\n    for(register int i=0;i<=n;i++){\n        a[i]=read();\n    }\n    for(register int i=0;i<=m;i++){\n        b[i]=read();\n    }\n    while(li<(n+m+2)){\n        li=(li)<<1;\n        k++;\n    }\n    for(register int i=0;i<=li;i++){\n        r[i]=(r[i>>1]>>1)|((i&1)<<(k-1));\n    }\n    ntt(a,1);\n    ntt(b,1);\n    for(register int i=0;i<=li;i++){\n        a[i]*=b[i];\n        a[i]%=mod;\n    }\n    ntt(a,0);\n    long long inv=fast_power(li,mod-2);\n    for(register int i=0;i<=n+m;i++){\n        print((a[i]*inv)%mod);\n        putchar(' ');\n    }\n    return 0;\n}\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){\n        c=='-'?f=-1:1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<3)+(x<<1)+(c^48);\n        c=getchar();\n    }\n    return f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n```\n\n# 扩展题目\n","slug":"0003","published":1,"updated":"2024-01-08T11:14:27.656Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65sa0003rqaygts84jim","content":"<p>卷积：$h_i=\\sum _{j=0}^{i}f_j \\times g_{i-j}$，其中 $h_i$ 是多项式 $H$ 的 $i$ 次项系数。其实就是多项式乘法。</p>\n<h1 id=\"FFT（快速傅里叶变换）\"><a href=\"#FFT（快速傅里叶变换）\" class=\"headerlink\" title=\"FFT（快速傅里叶变换）\"></a>FFT（快速傅里叶变换）</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>直接朴素乘会导致太慢了，时间复杂度直逼 $\\mathcal{O}(n^2)$，仍然停留在多项式的系数表达式太浅薄了，可以尝试一下点值表达式。</p>\n<p>对于一个有 $n$ 项的多项式，只要取不同的 $n$ 个值即可确定这个多项式，如果直接把两个多项式同时取 $n$ 个值，再把相同 $x$ 值得到的结果相乘，最后转换为系数表达，时间复杂度不会有任何改进，所以可以从取值的方面来下功夫。</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h5 id=\"1-虚数：定义虚数单位-i-，保证-i-2-1-，则可以把一个虚数定义为-a-bi-，其中-a-b-是实数。\"><a href=\"#1-虚数：定义虚数单位-i-，保证-i-2-1-，则可以把一个虚数定义为-a-bi-，其中-a-b-是实数。\" class=\"headerlink\" title=\"1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。\"></a>1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。</h5><h5 id=\"2-数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\"><a href=\"#2-数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\" class=\"headerlink\" title=\"2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\"></a>2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。</h5><h5 id=\"3-模长、幅角：接下来以-x-y-代表从-0-0-到-x-y-的向量，模长记为-x-y-为-x-y-到-0-0-的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\"><a href=\"#3-模长、幅角：接下来以-x-y-代表从-0-0-到-x-y-的向量，模长记为-x-y-为-x-y-到-0-0-的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\" class=\"headerlink\" title=\"3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\"></a>3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。</h5><p><img src=\"E:\\1.PNG\" alt=\"\"></p>\n<h5 id=\"3-虚数的运算：\"><a href=\"#3-虚数的运算：\" class=\"headerlink\" title=\"3. 虚数的运算：\"></a>3. 虚数的运算：</h5><p>$<del>~</del>~~~~$加减法直接把实部和虚部分别相加即可。</p>\n<p>$<del>~</del>~~~~$乘法在代数意义上的运算：$(a+bi)\\times(c+di)$=$ac+adi+bci-bd$=$(ac-bd)+(ad+bc)i$</p>\n<p>$<del>~</del>~~~~$几何意义：幅角相加，模长相乘。</p>\n<h5 id=\"4-单位根\"><a href=\"#4-单位根\" class=\"headerlink\" title=\"4.单位根\"></a>4.单位根</h5><p>$<del>~</del>~~~~$定义 $\\omega_n$ 为 $\\omega_n^n=1$，很容易推出其中一个单位根为模长为1，幅角为$360/n$，很容易想到这个数自乘 $n$ 次，旋转 $360$度，与正实轴重合，模长为1，$\\omega_n^k$也满足${(\\omega_n^k)}^n=1$，证明同理。</p>\n<h5 id=\"5-单位根性质\"><a href=\"#5-单位根性质\" class=\"headerlink\" title=\"5.单位根性质\"></a>5.单位根性质</h5><p>$<del>~</del>~~~~$ $\\omega_n^k=\\omega_{n/2}^{k/2}$ ，证明：$\\omega_n^k$为模长为1，幅角为$\\frac{360k}{n}$度，$\\omega_{n/2}^{k/2}$也是一样的。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^{k}=-\\omega_n^{k+n/2}$, 证明：多转了180度，所以就是相反数。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^0=\\omega_n^n=1$，由定义得。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^{k}=\\omega_n^{n+k}$，证明：转360度转回来了。</p>\n<h2 id=\"正向FFT（系数到点值）\"><a href=\"#正向FFT（系数到点值）\" class=\"headerlink\" title=\"正向FFT（系数到点值）\"></a>正向FFT（系数到点值）</h2><p>可以代入所有的单位根，为了统一计算，把所有的多项式补全到 $2^k$，其中k是满足 $2^k \\leq n+m+1$的最小值。高次项全部补0即可。</p>\n<p>$A(x)=(a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1})$</p>\n<p>按照次数奇偶性分组，$A(x)=(a_0+a_2x^2+…+a_{n-2}x^{n-2})+(a_1x+a_3x^3+…+a_{n-1}x^{n-1})$</p>\n<p>继续定义 B(x)=a_0+a_2x+a_4x^2+…+a_{n-2}x^{(n-2)/2}$</p>\n<p>$C(x)=a_1+a_3x+a_5x^2+…+a_{n-1}x^{(n-2)/2}$</p>\n<p>则 $A(x)=B(x^2)+xC(x^2)$</p>\n<p>将 $\\omega_n^k$ 代入原式得 $A(\\omega_n^k)=B(\\omega_n^{2k})+\\omega_n^kC(\\omega_n^{2k})$，因为相比原式项数减半所以把 $\\omega_n^{2k}$ 化为 $\\omega_{n/2}^k$得 $A(\\omega_n^k)=B(\\omega_{n/2}^k)+\\omega_n^kC(\\omega_{n/2}^k)$</p>\n<p>$B,C$递归处理即可。</p>\n<h2 id=\"IFFT（逆变换）\"><a href=\"#IFFT（逆变换）\" class=\"headerlink\" title=\"IFFT（逆变换）\"></a>IFFT（逆变换）</h2><p>上面算出来了点值表示法，如何转成系数表达式捏。</p>\n<p>设原多项式的点值表达式在 $\\omega_n^k(0 \\leq k&lt;n)$ 得到 $y_0,y_1,…,y_{n-1}$</p>\n<p>设多项式 $D(x)=y_0+y_1x+y_2x^2+y_3x^3+…y_{n-1}x^{n-1}$。</p>\n<p>设在 $\\omega_n^{-k}(0 \\leq k&lt;n)$的 点值表达式是 $z_0,z_1,…,z_{n-1}$。</p>\n<p>可证得$c_k=\\sum_{i=0}^{n-1}a_j(\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i)$</p>\n<p>核心的就是$\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i$，设$S(x)=\\sum^{n-1}_{i=0}x^i$</p>\n<p>易证 $S(x)=\\frac {1-1}{w_n^k-1}$</p>\n<p>当$w_n^k!=1$时，$S(x)=0$</p>\n<p>当$w_n^k=1$时，$S(x)=n$</p>\n<p>代入得$c_k=na_k$</p>\n<p>所以 $a_k=c_k/n$</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>递归实现容易爆栈，而且极其慢，考虑优化为迭代实现。</p>\n<p>优化为迭代实现的瓶颈在于如何划分系数，不过可以非常简单的把需要合并在一起的项放在一起。</p>\n<p>只有一项的多项式，点值表达式和系数表达式是一样的。</p>\n<p>因为上述按奇偶性分开，其实是按照下标二进制表达从后往前来比较的来划分的，相同的会放在一起，所以可以直接按照下表二进制反转的顺序来依次合并。</p>\n<pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;complex&gt;\n#include &lt;cmath&gt;\n#define int long long\ninline int read();\nconst double Pi=acos(-1.0);\nstd::complex &lt;double&gt; f[8000005],g[8000005],ans[8000005];\nint r[8000005];\nvoid fft(std::complex &lt;double&gt; *f,int limit,int type);\nsigned main()&#123;\n    int n=read(),m;\n\n    std::complex &lt;double&gt; temp=f[0];\n    m=read();\n    int limit=1,k=0;\n    while(limit&lt;(n+m+2))&#123;\n        limit=(limit)&lt;&lt;1;\n        k++;\n    &#125;\n    for(int i=0;i&lt;=n;i++)&#123;\n        f[i]=read();\n    &#125;\n    for(int i=0;i&lt;=m;i++)&#123;\n        g[i]=read();\n    &#125;\n    for(int i=0;i&lt;=limit;i++)&#123;\n        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(k-1));\n    &#125;\n    fft(f,limit,1);\n    fft(g,limit,1);\n    for(int i=0;i&lt;=limit;i++)&#123;\n        f[i]*=g[i];\n    &#125;\n    fft(f,limit,-1);\n    for(int i=0;i&lt;=n+m;i++)&#123;\n        printf(&quot;%lld &quot;,(int)(f[i].real()/(limit)+0.5));\n    &#125;\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\nvoid fft(std::complex &lt;double&gt; *f,int limit,int type)&#123;\n    for(int i=0;i&lt;=limit;i++)&#123;\n        if(i&lt;r[i])&#123;\n            swap(f[i],f[r[i]]);\n        &#125;\n    &#125;\n    for(int length=2;length&lt;=limit;length=(length&lt;&lt;1))&#123;\n        std::complex &lt;double&gt; Wn (std::cos(Pi*2/length),std::sin(type*Pi*2/length));\n        for(int i=0;i&lt;=limit;i+=length)&#123;\n            std::complex &lt;double&gt; wn1(1,0);\n            for(int k=i;k&lt;length/2+i;k++,wn1=wn1*Wn)&#123;\n                std::complex &lt;double&gt; x=f[k],y=f[k+length/2]*wn1;\n                f[k]=x+y;\n                f[k+length/2]=x-y;\n            &#125;\n        &#125;\n    &#125;\n    return ;\n&#125;\n</code></pre>\n<h1 id=\"NTT-快速数论变换\"><a href=\"#NTT-快速数论变换\" class=\"headerlink\" title=\"NTT (快速数论变换)\"></a>NTT (快速数论变换)</h1><h2 id=\"思想-1\"><a href=\"#思想-1\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>因为FFT涉及到复杂的复数运算，不仅很慢，不能取模，甚至有精度问题。</p>\n<p>所有如果在取模意义下，也可以用与FFT所利用的的单位根相似的原根。</p>\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><p>原根的定义理所当然，定义一个数 $n$ 的原根为 $g$ ，是满足$g^n \\equiv 1(mod~p)$的最小整数。</p>\n<p>原根满足 $g^i(1 \\leq i \\leq n)$ 模 $p$ 两两不同。</p>\n<p>一般取模数为 $998244353$ ，其原根是 $3$。</p>\n<p>对于代值的数的表示仍然是$\\omega_n$：</p>\n<p>$w_n \\equiv g^{\\frac{p-1}{n}} (mod~p)$</p>\n<p>$\\omega_n^k=\\omega_{n/2}^{k/2}$ 。</p>\n<p>$\\omega_n^{k}=-\\omega_n^{k+n/2}$。</p>\n<p>$\\omega_n^0=\\omega_n^n=1$。</p>\n<p>$\\omega_n^{k}=\\omega_n^{n+k}$。</p>\n<h2 id=\"直接把FFT的代值改成NTT\"><a href=\"#直接把FFT的代值改成NTT\" class=\"headerlink\" title=\"直接把FFT的代值改成NTT\"></a>直接把FFT的代值改成NTT</h2><pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#define int long long\ninline int read();\nint a[8000005],b[8000005];\nint li=1,k=0;\nint r[8000005];\nconst int mod=998244353;\nconst int g=3;\nconst int g2=332748118;\nvoid print(int x)&#123;\n    register char s[20];\n    register int i=0;\n    if(x&lt;0)&#123;\n        x=-x;\n        putchar(&#39;-&#39;);\n    &#125;\n    if(x==0)&#123;\n        putchar(&#39;0&#39;);\n        return;\n    &#125;\n    while(x)&#123;\n        s[i++]=x%10;\n        x/=10;\n    &#125;\n    while(i)&#123;\n        putchar(s[--i]+&#39;0&#39;);\n    &#125;\n    return;\n&#125;\ninline int fast_power(int a, int k) //快速幂，a为底数，k为指数\n&#123;\n    register int res = 1;\n    while (k)\n    &#123;\n        if (k &amp; 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline void ntt(int *a,int type)&#123;\n    for(register int i=0;i&lt;=li;i++)&#123;\n        if(i&lt;r[i])&#123;\n            std::swap(a[i],a[r[i]]);\n        &#125;\n    &#125;\n    int gn;\n    for(register int i=1;i&lt;li;i&lt;&lt;=1)&#123;\n        gn=fast_power(type?g:g2,(mod-1)/(i&lt;&lt;1));\n        for(register int j=0;j&lt;li;j+=(i&lt;&lt;1))&#123;\n            int g0=1;\n            for(int k=0;k&lt;i;k++,g0=(g0*gn)%mod)&#123;\n                int x=a[j+k];\n                int y=(a[i+j+k]*g0)%mod;\n                a[j+k]=(x+y)%mod;\n                a[i+j+k]=(x-y+mod)%mod;\n            &#125;\n        &#125;\n    &#125;\n    return ;\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE\n    #else\n    // freopen(&quot;.in&quot;,&quot;r&quot;,stdin);\n    // freopen(&quot;.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),m=read();\n    for(register int i=0;i&lt;=n;i++)&#123;\n        a[i]=read();\n    &#125;\n    for(register int i=0;i&lt;=m;i++)&#123;\n        b[i]=read();\n    &#125;\n    while(li&lt;(n+m+2))&#123;\n        li=(li)&lt;&lt;1;\n        k++;\n    &#125;\n    for(register int i=0;i&lt;=li;i++)&#123;\n        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(k-1));\n    &#125;\n    ntt(a,1);\n    ntt(b,1);\n    for(register int i=0;i&lt;=li;i++)&#123;\n        a[i]*=b[i];\n        a[i]%=mod;\n    &#125;\n    ntt(a,0);\n    long long inv=fast_power(li,mod-2);\n    for(register int i=0;i&lt;=n+m;i++)&#123;\n        print((a[i]*inv)%mod);\n        putchar(&#39; &#39;);\n    &#125;\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n<h1 id=\"扩展题目\"><a href=\"#扩展题目\" class=\"headerlink\" title=\"扩展题目\"></a>扩展题目</h1>","excerpt":"","more":"<p>卷积：$h_i=\\sum _{j=0}^{i}f_j \\times g_{i-j}$，其中 $h_i$ 是多项式 $H$ 的 $i$ 次项系数。其实就是多项式乘法。</p>\n<h1 id=\"FFT（快速傅里叶变换）\"><a href=\"#FFT（快速傅里叶变换）\" class=\"headerlink\" title=\"FFT（快速傅里叶变换）\"></a>FFT（快速傅里叶变换）</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>直接朴素乘会导致太慢了，时间复杂度直逼 $\\mathcal{O}(n^2)$，仍然停留在多项式的系数表达式太浅薄了，可以尝试一下点值表达式。</p>\n<p>对于一个有 $n$ 项的多项式，只要取不同的 $n$ 个值即可确定这个多项式，如果直接把两个多项式同时取 $n$ 个值，再把相同 $x$ 值得到的结果相乘，最后转换为系数表达，时间复杂度不会有任何改进，所以可以从取值的方面来下功夫。</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h5 id=\"1-虚数：定义虚数单位-i-，保证-i-2-1-，则可以把一个虚数定义为-a-bi-，其中-a-b-是实数。\"><a href=\"#1-虚数：定义虚数单位-i-，保证-i-2-1-，则可以把一个虚数定义为-a-bi-，其中-a-b-是实数。\" class=\"headerlink\" title=\"1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。\"></a>1. 虚数：定义虚数单位 $i$ ，保证 $i^2=-1$，则可以把一个虚数定义为 $a+bi$，其中 $a,b$ 是实数。</h5><h5 id=\"2-数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\"><a href=\"#2-数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\" class=\"headerlink\" title=\"2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。\"></a>2. 数轴：定义一个平面直角坐标系，横轴为实轴，纵轴为虚轴，这个坐标系定义是复数平面，任意一个点都代表一个实数或虚数，横坐标为其实部，纵坐标为其虚部。</h5><h5 id=\"3-模长、幅角：接下来以-x-y-代表从-0-0-到-x-y-的向量，模长记为-x-y-为-x-y-到-0-0-的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\"><a href=\"#3-模长、幅角：接下来以-x-y-代表从-0-0-到-x-y-的向量，模长记为-x-y-为-x-y-到-0-0-的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\" class=\"headerlink\" title=\"3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。\"></a>3. 模长、幅角：接下来以 $(x,y)$ 代表从 $(0,0)$ 到 $(x,y)$ 的向量，模长记为 $|(x,y)|$ 为 $(x,y)$ 到 $(0,0)$ 的欧几里得距离，幅角定义为正实部逆时针旋转一个幅角即可与向量重合。</h5><p><img src=\"E:\\1.PNG\" alt=\"\"></p>\n<h5 id=\"3-虚数的运算：\"><a href=\"#3-虚数的运算：\" class=\"headerlink\" title=\"3. 虚数的运算：\"></a>3. 虚数的运算：</h5><p>$<del>~</del>~~~~$加减法直接把实部和虚部分别相加即可。</p>\n<p>$<del>~</del>~~~~$乘法在代数意义上的运算：$(a+bi)\\times(c+di)$=$ac+adi+bci-bd$=$(ac-bd)+(ad+bc)i$</p>\n<p>$<del>~</del>~~~~$几何意义：幅角相加，模长相乘。</p>\n<h5 id=\"4-单位根\"><a href=\"#4-单位根\" class=\"headerlink\" title=\"4.单位根\"></a>4.单位根</h5><p>$<del>~</del>~~~~$定义 $\\omega_n$ 为 $\\omega_n^n=1$，很容易推出其中一个单位根为模长为1，幅角为$360/n$，很容易想到这个数自乘 $n$ 次，旋转 $360$度，与正实轴重合，模长为1，$\\omega_n^k$也满足${(\\omega_n^k)}^n=1$，证明同理。</p>\n<h5 id=\"5-单位根性质\"><a href=\"#5-单位根性质\" class=\"headerlink\" title=\"5.单位根性质\"></a>5.单位根性质</h5><p>$<del>~</del>~~~~$ $\\omega_n^k=\\omega_{n/2}^{k/2}$ ，证明：$\\omega_n^k$为模长为1，幅角为$\\frac{360k}{n}$度，$\\omega_{n/2}^{k/2}$也是一样的。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^{k}=-\\omega_n^{k+n/2}$, 证明：多转了180度，所以就是相反数。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^0=\\omega_n^n=1$，由定义得。</p>\n<p>$<del>~</del>~~~~$ $\\omega_n^{k}=\\omega_n^{n+k}$，证明：转360度转回来了。</p>\n<h2 id=\"正向FFT（系数到点值）\"><a href=\"#正向FFT（系数到点值）\" class=\"headerlink\" title=\"正向FFT（系数到点值）\"></a>正向FFT（系数到点值）</h2><p>可以代入所有的单位根，为了统一计算，把所有的多项式补全到 $2^k$，其中k是满足 $2^k \\leq n+m+1$的最小值。高次项全部补0即可。</p>\n<p>$A(x)=(a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1})$</p>\n<p>按照次数奇偶性分组，$A(x)=(a_0+a_2x^2+…+a_{n-2}x^{n-2})+(a_1x+a_3x^3+…+a_{n-1}x^{n-1})$</p>\n<p>继续定义 B(x)=a_0+a_2x+a_4x^2+…+a_{n-2}x^{(n-2)/2}$</p>\n<p>$C(x)=a_1+a_3x+a_5x^2+…+a_{n-1}x^{(n-2)/2}$</p>\n<p>则 $A(x)=B(x^2)+xC(x^2)$</p>\n<p>将 $\\omega_n^k$ 代入原式得 $A(\\omega_n^k)=B(\\omega_n^{2k})+\\omega_n^kC(\\omega_n^{2k})$，因为相比原式项数减半所以把 $\\omega_n^{2k}$ 化为 $\\omega_{n/2}^k$得 $A(\\omega_n^k)=B(\\omega_{n/2}^k)+\\omega_n^kC(\\omega_{n/2}^k)$</p>\n<p>$B,C$递归处理即可。</p>\n<h2 id=\"IFFT（逆变换）\"><a href=\"#IFFT（逆变换）\" class=\"headerlink\" title=\"IFFT（逆变换）\"></a>IFFT（逆变换）</h2><p>上面算出来了点值表示法，如何转成系数表达式捏。</p>\n<p>设原多项式的点值表达式在 $\\omega_n^k(0 \\leq k&lt;n)$ 得到 $y_0,y_1,…,y_{n-1}$</p>\n<p>设多项式 $D(x)=y_0+y_1x+y_2x^2+y_3x^3+…y_{n-1}x^{n-1}$。</p>\n<p>设在 $\\omega_n^{-k}(0 \\leq k&lt;n)$的 点值表达式是 $z_0,z_1,…,z_{n-1}$。</p>\n<p>可证得$c_k=\\sum_{i=0}^{n-1}a_j(\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i)$</p>\n<p>核心的就是$\\sum^{n-1}_{i=0}(\\omega_n^{j-k})^i$，设$S(x)=\\sum^{n-1}_{i=0}x^i$</p>\n<p>易证 $S(x)=\\frac {1-1}{w_n^k-1}$</p>\n<p>当$w_n^k!=1$时，$S(x)=0$</p>\n<p>当$w_n^k=1$时，$S(x)=n$</p>\n<p>代入得$c_k=na_k$</p>\n<p>所以 $a_k=c_k/n$</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>递归实现容易爆栈，而且极其慢，考虑优化为迭代实现。</p>\n<p>优化为迭代实现的瓶颈在于如何划分系数，不过可以非常简单的把需要合并在一起的项放在一起。</p>\n<p>只有一项的多项式，点值表达式和系数表达式是一样的。</p>\n<p>因为上述按奇偶性分开，其实是按照下标二进制表达从后往前来比较的来划分的，相同的会放在一起，所以可以直接按照下表二进制反转的顺序来依次合并。</p>\n<pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;complex&gt;\n#include &lt;cmath&gt;\n#define int long long\ninline int read();\nconst double Pi=acos(-1.0);\nstd::complex &lt;double&gt; f[8000005],g[8000005],ans[8000005];\nint r[8000005];\nvoid fft(std::complex &lt;double&gt; *f,int limit,int type);\nsigned main()&#123;\n    int n=read(),m;\n\n    std::complex &lt;double&gt; temp=f[0];\n    m=read();\n    int limit=1,k=0;\n    while(limit&lt;(n+m+2))&#123;\n        limit=(limit)&lt;&lt;1;\n        k++;\n    &#125;\n    for(int i=0;i&lt;=n;i++)&#123;\n        f[i]=read();\n    &#125;\n    for(int i=0;i&lt;=m;i++)&#123;\n        g[i]=read();\n    &#125;\n    for(int i=0;i&lt;=limit;i++)&#123;\n        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(k-1));\n    &#125;\n    fft(f,limit,1);\n    fft(g,limit,1);\n    for(int i=0;i&lt;=limit;i++)&#123;\n        f[i]*=g[i];\n    &#125;\n    fft(f,limit,-1);\n    for(int i=0;i&lt;=n+m;i++)&#123;\n        printf(&quot;%lld &quot;,(int)(f[i].real()/(limit)+0.5));\n    &#125;\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\nvoid fft(std::complex &lt;double&gt; *f,int limit,int type)&#123;\n    for(int i=0;i&lt;=limit;i++)&#123;\n        if(i&lt;r[i])&#123;\n            swap(f[i],f[r[i]]);\n        &#125;\n    &#125;\n    for(int length=2;length&lt;=limit;length=(length&lt;&lt;1))&#123;\n        std::complex &lt;double&gt; Wn (std::cos(Pi*2/length),std::sin(type*Pi*2/length));\n        for(int i=0;i&lt;=limit;i+=length)&#123;\n            std::complex &lt;double&gt; wn1(1,0);\n            for(int k=i;k&lt;length/2+i;k++,wn1=wn1*Wn)&#123;\n                std::complex &lt;double&gt; x=f[k],y=f[k+length/2]*wn1;\n                f[k]=x+y;\n                f[k+length/2]=x-y;\n            &#125;\n        &#125;\n    &#125;\n    return ;\n&#125;\n</code></pre>\n<h1 id=\"NTT-快速数论变换\"><a href=\"#NTT-快速数论变换\" class=\"headerlink\" title=\"NTT (快速数论变换)\"></a>NTT (快速数论变换)</h1><h2 id=\"思想-1\"><a href=\"#思想-1\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>因为FFT涉及到复杂的复数运算，不仅很慢，不能取模，甚至有精度问题。</p>\n<p>所有如果在取模意义下，也可以用与FFT所利用的的单位根相似的原根。</p>\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><p>原根的定义理所当然，定义一个数 $n$ 的原根为 $g$ ，是满足$g^n \\equiv 1(mod~p)$的最小整数。</p>\n<p>原根满足 $g^i(1 \\leq i \\leq n)$ 模 $p$ 两两不同。</p>\n<p>一般取模数为 $998244353$ ，其原根是 $3$。</p>\n<p>对于代值的数的表示仍然是$\\omega_n$：</p>\n<p>$w_n \\equiv g^{\\frac{p-1}{n}} (mod~p)$</p>\n<p>$\\omega_n^k=\\omega_{n/2}^{k/2}$ 。</p>\n<p>$\\omega_n^{k}=-\\omega_n^{k+n/2}$。</p>\n<p>$\\omega_n^0=\\omega_n^n=1$。</p>\n<p>$\\omega_n^{k}=\\omega_n^{n+k}$。</p>\n<h2 id=\"直接把FFT的代值改成NTT\"><a href=\"#直接把FFT的代值改成NTT\" class=\"headerlink\" title=\"直接把FFT的代值改成NTT\"></a>直接把FFT的代值改成NTT</h2><pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#define int long long\ninline int read();\nint a[8000005],b[8000005];\nint li=1,k=0;\nint r[8000005];\nconst int mod=998244353;\nconst int g=3;\nconst int g2=332748118;\nvoid print(int x)&#123;\n    register char s[20];\n    register int i=0;\n    if(x&lt;0)&#123;\n        x=-x;\n        putchar(&#39;-&#39;);\n    &#125;\n    if(x==0)&#123;\n        putchar(&#39;0&#39;);\n        return;\n    &#125;\n    while(x)&#123;\n        s[i++]=x%10;\n        x/=10;\n    &#125;\n    while(i)&#123;\n        putchar(s[--i]+&#39;0&#39;);\n    &#125;\n    return;\n&#125;\ninline int fast_power(int a, int k) //快速幂，a为底数，k为指数\n&#123;\n    register int res = 1;\n    while (k)\n    &#123;\n        if (k &amp; 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline void ntt(int *a,int type)&#123;\n    for(register int i=0;i&lt;=li;i++)&#123;\n        if(i&lt;r[i])&#123;\n            std::swap(a[i],a[r[i]]);\n        &#125;\n    &#125;\n    int gn;\n    for(register int i=1;i&lt;li;i&lt;&lt;=1)&#123;\n        gn=fast_power(type?g:g2,(mod-1)/(i&lt;&lt;1));\n        for(register int j=0;j&lt;li;j+=(i&lt;&lt;1))&#123;\n            int g0=1;\n            for(int k=0;k&lt;i;k++,g0=(g0*gn)%mod)&#123;\n                int x=a[j+k];\n                int y=(a[i+j+k]*g0)%mod;\n                a[j+k]=(x+y)%mod;\n                a[i+j+k]=(x-y+mod)%mod;\n            &#125;\n        &#125;\n    &#125;\n    return ;\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE\n    #else\n    // freopen(&quot;.in&quot;,&quot;r&quot;,stdin);\n    // freopen(&quot;.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),m=read();\n    for(register int i=0;i&lt;=n;i++)&#123;\n        a[i]=read();\n    &#125;\n    for(register int i=0;i&lt;=m;i++)&#123;\n        b[i]=read();\n    &#125;\n    while(li&lt;(n+m+2))&#123;\n        li=(li)&lt;&lt;1;\n        k++;\n    &#125;\n    for(register int i=0;i&lt;=li;i++)&#123;\n        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(k-1));\n    &#125;\n    ntt(a,1);\n    ntt(b,1);\n    for(register int i=0;i&lt;=li;i++)&#123;\n        a[i]*=b[i];\n        a[i]%=mod;\n    &#125;\n    ntt(a,0);\n    long long inv=fast_power(li,mod-2);\n    for(register int i=0;i&lt;=n+m;i++)&#123;\n        print((a[i]*inv)%mod);\n        putchar(&#39; &#39;);\n    &#125;\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n<h1 id=\"扩展题目\"><a href=\"#扩展题目\" class=\"headerlink\" title=\"扩展题目\"></a>扩展题目</h1>"},{"title":"CSP2023-S模拟赛（五）赛后总结","date":"2023-07-20T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# CSP2023-S模拟赛（五）赛后总结\n\n## 生成树\n\n### 简要题解\n\n最小生成树依次连接 $i$ 和 $i+1$ ，最小为 $n-1$ 。\n\n最大生成树从大到小枚举边权，然后这个边权的倍数都可以连接，因为这些点的最大公因数一定是当前枚举的边权的整倍数，一定在枚举这个边权之前枚举了，并查集判断是否已连接即可。\n\n时间复杂度比较难说，但是很容易看到随着 $n$ 增大，时间复杂度肯定越大，经测试最大的 $n$ 能够跑过，所以没问题。\n\n## 总结\n\n考虑最小/大生成树的经典算法，是每次找剩余的边权中最大的，所以考虑从大到小枚举，同时推出正确性，其实是不难想到的。\n\n## 序列\n\n### 简要题解\n\n考虑DP，式子推出后用矩阵乘法改写，然后优化。\n\n### 总结\n\nDP推出后，可从DP式本身出发，也可以考虑改写为矩阵乘法甚至是广义矩阵乘法，在发现DP状态数较多的情况下，可以考虑DP转移本身需要哪些信息，哪些信息可以合并，从而降低时间复杂度和空间时间度。\n\n## 魔力\n\n### 简要题解\n\n计算移动每个点会造成的差值，会发现他们互相不影响，排序即可。\n\n### 总结\n\n对于计数问题，可以考虑每种操作对最终答案的影响，根据题目中信息将在线问题转换为离线问题。\n\n## 时空结构\n\n### 简要题解\n\n访问过程中，考虑祖先节点对儿子的影响，然后将式子化简得出结论。\n\n### 总结\n\n对于每个节点可以拆开计算的问题，可以考虑分别拆开然后处理出每个值然后合并。\n\n树上问题可以考虑拆成一条条链来处理。\n","source":"_posts/0004.md","raw":"---\ntitle: CSP2023-S模拟赛（五）赛后总结\ndate: 2023-07-21\ntags: [OI]\ntoc: true\nmathjax: true\n---\n\n# CSP2023-S模拟赛（五）赛后总结\n\n## 生成树\n\n### 简要题解\n\n最小生成树依次连接 $i$ 和 $i+1$ ，最小为 $n-1$ 。\n\n最大生成树从大到小枚举边权，然后这个边权的倍数都可以连接，因为这些点的最大公因数一定是当前枚举的边权的整倍数，一定在枚举这个边权之前枚举了，并查集判断是否已连接即可。\n\n时间复杂度比较难说，但是很容易看到随着 $n$ 增大，时间复杂度肯定越大，经测试最大的 $n$ 能够跑过，所以没问题。\n\n## 总结\n\n考虑最小/大生成树的经典算法，是每次找剩余的边权中最大的，所以考虑从大到小枚举，同时推出正确性，其实是不难想到的。\n\n## 序列\n\n### 简要题解\n\n考虑DP，式子推出后用矩阵乘法改写，然后优化。\n\n### 总结\n\nDP推出后，可从DP式本身出发，也可以考虑改写为矩阵乘法甚至是广义矩阵乘法，在发现DP状态数较多的情况下，可以考虑DP转移本身需要哪些信息，哪些信息可以合并，从而降低时间复杂度和空间时间度。\n\n## 魔力\n\n### 简要题解\n\n计算移动每个点会造成的差值，会发现他们互相不影响，排序即可。\n\n### 总结\n\n对于计数问题，可以考虑每种操作对最终答案的影响，根据题目中信息将在线问题转换为离线问题。\n\n## 时空结构\n\n### 简要题解\n\n访问过程中，考虑祖先节点对儿子的影响，然后将式子化简得出结论。\n\n### 总结\n\n对于每个节点可以拆开计算的问题，可以考虑分别拆开然后处理出每个值然后合并。\n\n树上问题可以考虑拆成一条条链来处理。\n","slug":"0004","published":1,"updated":"2024-01-08T11:15:06.847Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65sg0004rqayaaf1fdec","content":"<h1 id=\"CSP2023-S模拟赛（五）赛后总结\"><a href=\"#CSP2023-S模拟赛（五）赛后总结\" class=\"headerlink\" title=\"CSP2023-S模拟赛（五）赛后总结\"></a>CSP2023-S模拟赛（五）赛后总结</h1><h2 id=\"生成树\"><a href=\"#生成树\" class=\"headerlink\" title=\"生成树\"></a>生成树</h2><h3 id=\"简要题解\"><a href=\"#简要题解\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>最小生成树依次连接 $i$ 和 $i+1$ ，最小为 $n-1$ 。</p>\n<p>最大生成树从大到小枚举边权，然后这个边权的倍数都可以连接，因为这些点的最大公因数一定是当前枚举的边权的整倍数，一定在枚举这个边权之前枚举了，并查集判断是否已连接即可。</p>\n<p>时间复杂度比较难说，但是很容易看到随着 $n$ 增大，时间复杂度肯定越大，经测试最大的 $n$ 能够跑过，所以没问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考虑最小/大生成树的经典算法，是每次找剩余的边权中最大的，所以考虑从大到小枚举，同时推出正确性，其实是不难想到的。</p>\n<h2 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h2><h3 id=\"简要题解-1\"><a href=\"#简要题解-1\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>考虑DP，式子推出后用矩阵乘法改写，然后优化。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>DP推出后，可从DP式本身出发，也可以考虑改写为矩阵乘法甚至是广义矩阵乘法，在发现DP状态数较多的情况下，可以考虑DP转移本身需要哪些信息，哪些信息可以合并，从而降低时间复杂度和空间时间度。</p>\n<h2 id=\"魔力\"><a href=\"#魔力\" class=\"headerlink\" title=\"魔力\"></a>魔力</h2><h3 id=\"简要题解-2\"><a href=\"#简要题解-2\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>计算移动每个点会造成的差值，会发现他们互相不影响，排序即可。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于计数问题，可以考虑每种操作对最终答案的影响，根据题目中信息将在线问题转换为离线问题。</p>\n<h2 id=\"时空结构\"><a href=\"#时空结构\" class=\"headerlink\" title=\"时空结构\"></a>时空结构</h2><h3 id=\"简要题解-3\"><a href=\"#简要题解-3\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>访问过程中，考虑祖先节点对儿子的影响，然后将式子化简得出结论。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于每个节点可以拆开计算的问题，可以考虑分别拆开然后处理出每个值然后合并。</p>\n<p>树上问题可以考虑拆成一条条链来处理。</p>\n","excerpt":"","more":"<h1 id=\"CSP2023-S模拟赛（五）赛后总结\"><a href=\"#CSP2023-S模拟赛（五）赛后总结\" class=\"headerlink\" title=\"CSP2023-S模拟赛（五）赛后总结\"></a>CSP2023-S模拟赛（五）赛后总结</h1><h2 id=\"生成树\"><a href=\"#生成树\" class=\"headerlink\" title=\"生成树\"></a>生成树</h2><h3 id=\"简要题解\"><a href=\"#简要题解\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>最小生成树依次连接 $i$ 和 $i+1$ ，最小为 $n-1$ 。</p>\n<p>最大生成树从大到小枚举边权，然后这个边权的倍数都可以连接，因为这些点的最大公因数一定是当前枚举的边权的整倍数，一定在枚举这个边权之前枚举了，并查集判断是否已连接即可。</p>\n<p>时间复杂度比较难说，但是很容易看到随着 $n$ 增大，时间复杂度肯定越大，经测试最大的 $n$ 能够跑过，所以没问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考虑最小/大生成树的经典算法，是每次找剩余的边权中最大的，所以考虑从大到小枚举，同时推出正确性，其实是不难想到的。</p>\n<h2 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h2><h3 id=\"简要题解-1\"><a href=\"#简要题解-1\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>考虑DP，式子推出后用矩阵乘法改写，然后优化。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>DP推出后，可从DP式本身出发，也可以考虑改写为矩阵乘法甚至是广义矩阵乘法，在发现DP状态数较多的情况下，可以考虑DP转移本身需要哪些信息，哪些信息可以合并，从而降低时间复杂度和空间时间度。</p>\n<h2 id=\"魔力\"><a href=\"#魔力\" class=\"headerlink\" title=\"魔力\"></a>魔力</h2><h3 id=\"简要题解-2\"><a href=\"#简要题解-2\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>计算移动每个点会造成的差值，会发现他们互相不影响，排序即可。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于计数问题，可以考虑每种操作对最终答案的影响，根据题目中信息将在线问题转换为离线问题。</p>\n<h2 id=\"时空结构\"><a href=\"#时空结构\" class=\"headerlink\" title=\"时空结构\"></a>时空结构</h2><h3 id=\"简要题解-3\"><a href=\"#简要题解-3\" class=\"headerlink\" title=\"简要题解\"></a>简要题解</h3><p>访问过程中，考虑祖先节点对儿子的影响，然后将式子化简得出结论。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于每个节点可以拆开计算的问题，可以考虑分别拆开然后处理出每个值然后合并。</p>\n<p>树上问题可以考虑拆成一条条链来处理。</p>\n"},{"title":"NOI Linux2.0考场环境使用指南","date":"2023-07-07T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# NOI Linux2.0考场环境使用指南\n\n## 编写代码\n\n### Code::Blocks\n\n![1.png](1.png)\n\nCode::Blocks是考场唯一一个可以图形化调试的IDE，但是极为难用。\n\n#### 创建项目\n\n![2.PNG](D:\\OI\\2.PNG)\n\n![3.PNG](D:\\OI\\3.PNG)\n\n![4.PNG](D:\\OI\\4.PNG)\n\n![5.PNG](D:\\OI\\5.PNG)\n\n#### 更改终端\n\n![6.PNG](D:\\OI\\6.PNG)\n\n![7.PNG](D:\\OI\\7.PNG)\n\n\n\n然后就可以编代码啦，编译选项我也没找到在哪里改，反正不建议使用\n\n### 优雅折中的Geany\n\nGeany非常简单，打开后和Dev-C++非常相像，只可惜不能调试，只能单开终端调试，可以更改编译选项。\n\n![8.PNG](D:\\OI\\8.PNG)\n\n更改Build的编译选项即可，可以参照这个来写:\n\n```\ng++ \"%f\" -o \"%e\" -g -Wall -std=c++14 -fsanitize=address,undefined\n```\n\n后面一个神奇的编译选项将在后面提到。调试请参考VSCode的调试部分。\n\n### VSCode\n\n听说你想用机房很火的VSCode？哈哈，CCF提供的C/C++插件处于半残废状态，要想编译和调试只能手写JSON，反正我不会。\n\n但是VSCode的代码高亮等等等很好用，只是要手敲命令行，我认为还好。\n\n#### 打开工作区\n\n建议直接打开要求的代码保存目录。\n\n![9.PNG](D:\\OI\\9.PNG)\n\n#### 编译及运行\n\n在bash终端里面输入\n\n```bash\ng++  *.cpp -o * -g -Wall -std=c++14 -fsanitize=address,undefined\n```\n\n后面的很复杂的编译选项可以不管，这个是新版本g++加入的新功能，可以一定程度上避免程序的UB行为避免大部分RE。\n\n运行\n\n```bash\n./*\n```\n\n就可以像在Windows下一样输入了，Ctrl+C强制结束。\n\n#### 调试\n\n调试功能依赖于gdb。\n\n##### 注意事项：\n\n如果此行没有输入命令，按下回车，会自动执行上一行的内容，容易导致翻车\n\n##### 使用指南：\n\n进入gdb：\n\n```bash\ngdb *\n```\n\n查看源代码：\n\n```bash\nlist\n```\n\n就会列出代码，每次列出 $20$ 行，如果列出，说明可以开始调试，否则编译过程中可能没有加入 -g 选项。\n\n加入断点：\n\n```bash\nbreak xxx(行号)\n```\n\n运行：\n\n```bash\nrun\n```\n\n下一步：\n\n```bash\nnext\n```\n\n单步进入：\n\n```bash\nstep\n```\n\n跳过：\n\n```bash\ncontinue\n```\n\n查看变量值：\n\n```bash\nprint xxx(变量名)\n```\n\n应该只会用这些，多余的可以自行了解。\n\n[扩展](https://blog.csdn.net/qq_28351609/article/details/114855630)\n\n### NOI Linux的其他翻车细节\n\n#### Arbiter\n\narbiter别乱用，特别容易崩溃。\n\n#### 喜闻乐见.jpg\n\nscp?\n\nsshd被删了，别想着偷别人代码。\n\n#### 中文目录\n\n哪个zz想的Linux目录是中文啊啊啊，不要把代码复制到桌面，不要给文件名加上中文，否则编译错误满天飞。\n\n#### 编辑器崩溃\n\n不建议用编写代码的IDE来看样例，建议单独开一个，大样例会把编辑器搞崩溃，代码就没了。\n\n\n\n","source":"_posts/0005.md","raw":"---\ntitle: NOI Linux2.0考场环境使用指南\ndate: 2023-07-08\ntags: [OI,NOI_Linux]\ntoc: true\nmathjax: true\n---\n\n# NOI Linux2.0考场环境使用指南\n\n## 编写代码\n\n### Code::Blocks\n\n![1.png](1.png)\n\nCode::Blocks是考场唯一一个可以图形化调试的IDE，但是极为难用。\n\n#### 创建项目\n\n![2.PNG](D:\\OI\\2.PNG)\n\n![3.PNG](D:\\OI\\3.PNG)\n\n![4.PNG](D:\\OI\\4.PNG)\n\n![5.PNG](D:\\OI\\5.PNG)\n\n#### 更改终端\n\n![6.PNG](D:\\OI\\6.PNG)\n\n![7.PNG](D:\\OI\\7.PNG)\n\n\n\n然后就可以编代码啦，编译选项我也没找到在哪里改，反正不建议使用\n\n### 优雅折中的Geany\n\nGeany非常简单，打开后和Dev-C++非常相像，只可惜不能调试，只能单开终端调试，可以更改编译选项。\n\n![8.PNG](D:\\OI\\8.PNG)\n\n更改Build的编译选项即可，可以参照这个来写:\n\n```\ng++ \"%f\" -o \"%e\" -g -Wall -std=c++14 -fsanitize=address,undefined\n```\n\n后面一个神奇的编译选项将在后面提到。调试请参考VSCode的调试部分。\n\n### VSCode\n\n听说你想用机房很火的VSCode？哈哈，CCF提供的C/C++插件处于半残废状态，要想编译和调试只能手写JSON，反正我不会。\n\n但是VSCode的代码高亮等等等很好用，只是要手敲命令行，我认为还好。\n\n#### 打开工作区\n\n建议直接打开要求的代码保存目录。\n\n![9.PNG](D:\\OI\\9.PNG)\n\n#### 编译及运行\n\n在bash终端里面输入\n\n```bash\ng++  *.cpp -o * -g -Wall -std=c++14 -fsanitize=address,undefined\n```\n\n后面的很复杂的编译选项可以不管，这个是新版本g++加入的新功能，可以一定程度上避免程序的UB行为避免大部分RE。\n\n运行\n\n```bash\n./*\n```\n\n就可以像在Windows下一样输入了，Ctrl+C强制结束。\n\n#### 调试\n\n调试功能依赖于gdb。\n\n##### 注意事项：\n\n如果此行没有输入命令，按下回车，会自动执行上一行的内容，容易导致翻车\n\n##### 使用指南：\n\n进入gdb：\n\n```bash\ngdb *\n```\n\n查看源代码：\n\n```bash\nlist\n```\n\n就会列出代码，每次列出 $20$ 行，如果列出，说明可以开始调试，否则编译过程中可能没有加入 -g 选项。\n\n加入断点：\n\n```bash\nbreak xxx(行号)\n```\n\n运行：\n\n```bash\nrun\n```\n\n下一步：\n\n```bash\nnext\n```\n\n单步进入：\n\n```bash\nstep\n```\n\n跳过：\n\n```bash\ncontinue\n```\n\n查看变量值：\n\n```bash\nprint xxx(变量名)\n```\n\n应该只会用这些，多余的可以自行了解。\n\n[扩展](https://blog.csdn.net/qq_28351609/article/details/114855630)\n\n### NOI Linux的其他翻车细节\n\n#### Arbiter\n\narbiter别乱用，特别容易崩溃。\n\n#### 喜闻乐见.jpg\n\nscp?\n\nsshd被删了，别想着偷别人代码。\n\n#### 中文目录\n\n哪个zz想的Linux目录是中文啊啊啊，不要把代码复制到桌面，不要给文件名加上中文，否则编译错误满天飞。\n\n#### 编辑器崩溃\n\n不建议用编写代码的IDE来看样例，建议单独开一个，大样例会把编辑器搞崩溃，代码就没了。\n\n\n\n","slug":"0005","published":1,"updated":"2024-01-08T11:15:50.579Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65t40005rqay3vibh0rj","content":"<h1 id=\"NOI-Linux2-0考场环境使用指南\"><a href=\"#NOI-Linux2-0考场环境使用指南\" class=\"headerlink\" title=\"NOI Linux2.0考场环境使用指南\"></a>NOI Linux2.0考场环境使用指南</h1><h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><h3 id=\"Code-Blocks\"><a href=\"#Code-Blocks\" class=\"headerlink\" title=\"Code::Blocks\"></a>Code::Blocks</h3><p><img src=\"1.png\" alt=\"1.png\"></p>\n<p>Code::Blocks是考场唯一一个可以图形化调试的IDE，但是极为难用。</p>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p><img src=\"D:\\OI\\2.PNG\" alt=\"2.PNG\"></p>\n<p><img src=\"D:\\OI\\3.PNG\" alt=\"3.PNG\"></p>\n<p><img src=\"D:\\OI\\4.PNG\" alt=\"4.PNG\"></p>\n<p><img src=\"D:\\OI\\5.PNG\" alt=\"5.PNG\"></p>\n<h4 id=\"更改终端\"><a href=\"#更改终端\" class=\"headerlink\" title=\"更改终端\"></a>更改终端</h4><p><img src=\"D:\\OI\\6.PNG\" alt=\"6.PNG\"></p>\n<p><img src=\"D:\\OI\\7.PNG\" alt=\"7.PNG\"></p>\n<p>然后就可以编代码啦，编译选项我也没找到在哪里改，反正不建议使用</p>\n<h3 id=\"优雅折中的Geany\"><a href=\"#优雅折中的Geany\" class=\"headerlink\" title=\"优雅折中的Geany\"></a>优雅折中的Geany</h3><p>Geany非常简单，打开后和Dev-C++非常相像，只可惜不能调试，只能单开终端调试，可以更改编译选项。</p>\n<p><img src=\"D:\\OI\\8.PNG\" alt=\"8.PNG\"></p>\n<p>更改Build的编译选项即可，可以参照这个来写:</p>\n<pre><code>g++ &quot;%f&quot; -o &quot;%e&quot; -g -Wall -std=c++14 -fsanitize=address,undefined\n</code></pre><p>后面一个神奇的编译选项将在后面提到。调试请参考VSCode的调试部分。</p>\n<h3 id=\"VSCode\"><a href=\"#VSCode\" class=\"headerlink\" title=\"VSCode\"></a>VSCode</h3><p>听说你想用机房很火的VSCode？哈哈，CCF提供的C/C++插件处于半残废状态，要想编译和调试只能手写JSON，反正我不会。</p>\n<p>但是VSCode的代码高亮等等等很好用，只是要手敲命令行，我认为还好。</p>\n<h4 id=\"打开工作区\"><a href=\"#打开工作区\" class=\"headerlink\" title=\"打开工作区\"></a>打开工作区</h4><p>建议直接打开要求的代码保存目录。</p>\n<p><img src=\"D:\\OI\\9.PNG\" alt=\"9.PNG\"></p>\n<h4 id=\"编译及运行\"><a href=\"#编译及运行\" class=\"headerlink\" title=\"编译及运行\"></a>编译及运行</h4><p>在bash终端里面输入</p>\n<pre><code class=\"lang-bash\">g++  *.cpp -o * -g -Wall -std=c++14 -fsanitize=address,undefined\n</code></pre>\n<p>后面的很复杂的编译选项可以不管，这个是新版本g++加入的新功能，可以一定程度上避免程序的UB行为避免大部分RE。</p>\n<p>运行</p>\n<pre><code class=\"lang-bash\">./*\n</code></pre>\n<p>就可以像在Windows下一样输入了，Ctrl+C强制结束。</p>\n<h4 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h4><p>调试功能依赖于gdb。</p>\n<h5 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h5><p>如果此行没有输入命令，按下回车，会自动执行上一行的内容，容易导致翻车</p>\n<h5 id=\"使用指南：\"><a href=\"#使用指南：\" class=\"headerlink\" title=\"使用指南：\"></a>使用指南：</h5><p>进入gdb：</p>\n<pre><code class=\"lang-bash\">gdb *\n</code></pre>\n<p>查看源代码：</p>\n<pre><code class=\"lang-bash\">list\n</code></pre>\n<p>就会列出代码，每次列出 $20$ 行，如果列出，说明可以开始调试，否则编译过程中可能没有加入 -g 选项。</p>\n<p>加入断点：</p>\n<pre><code class=\"lang-bash\">break xxx(行号)\n</code></pre>\n<p>运行：</p>\n<pre><code class=\"lang-bash\">run\n</code></pre>\n<p>下一步：</p>\n<pre><code class=\"lang-bash\">next\n</code></pre>\n<p>单步进入：</p>\n<pre><code class=\"lang-bash\">step\n</code></pre>\n<p>跳过：</p>\n<pre><code class=\"lang-bash\">continue\n</code></pre>\n<p>查看变量值：</p>\n<pre><code class=\"lang-bash\">print xxx(变量名)\n</code></pre>\n<p>应该只会用这些，多余的可以自行了解。</p>\n<p><a href=\"https://blog.csdn.net/qq_28351609/article/details/114855630\">扩展</a></p>\n<h3 id=\"NOI-Linux的其他翻车细节\"><a href=\"#NOI-Linux的其他翻车细节\" class=\"headerlink\" title=\"NOI Linux的其他翻车细节\"></a>NOI Linux的其他翻车细节</h3><h4 id=\"Arbiter\"><a href=\"#Arbiter\" class=\"headerlink\" title=\"Arbiter\"></a>Arbiter</h4><p>arbiter别乱用，特别容易崩溃。</p>\n<h4 id=\"喜闻乐见-jpg\"><a href=\"#喜闻乐见-jpg\" class=\"headerlink\" title=\"喜闻乐见.jpg\"></a>喜闻乐见.jpg</h4><p>scp?</p>\n<p>sshd被删了，别想着偷别人代码。</p>\n<h4 id=\"中文目录\"><a href=\"#中文目录\" class=\"headerlink\" title=\"中文目录\"></a>中文目录</h4><p>哪个zz想的Linux目录是中文啊啊啊，不要把代码复制到桌面，不要给文件名加上中文，否则编译错误满天飞。</p>\n<h4 id=\"编辑器崩溃\"><a href=\"#编辑器崩溃\" class=\"headerlink\" title=\"编辑器崩溃\"></a>编辑器崩溃</h4><p>不建议用编写代码的IDE来看样例，建议单独开一个，大样例会把编辑器搞崩溃，代码就没了。</p>\n","excerpt":"","more":"<h1 id=\"NOI-Linux2-0考场环境使用指南\"><a href=\"#NOI-Linux2-0考场环境使用指南\" class=\"headerlink\" title=\"NOI Linux2.0考场环境使用指南\"></a>NOI Linux2.0考场环境使用指南</h1><h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><h3 id=\"Code-Blocks\"><a href=\"#Code-Blocks\" class=\"headerlink\" title=\"Code::Blocks\"></a>Code::Blocks</h3><p><img src=\"1.png\" alt=\"1.png\"></p>\n<p>Code::Blocks是考场唯一一个可以图形化调试的IDE，但是极为难用。</p>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p><img src=\"D:\\OI\\2.PNG\" alt=\"2.PNG\"></p>\n<p><img src=\"D:\\OI\\3.PNG\" alt=\"3.PNG\"></p>\n<p><img src=\"D:\\OI\\4.PNG\" alt=\"4.PNG\"></p>\n<p><img src=\"D:\\OI\\5.PNG\" alt=\"5.PNG\"></p>\n<h4 id=\"更改终端\"><a href=\"#更改终端\" class=\"headerlink\" title=\"更改终端\"></a>更改终端</h4><p><img src=\"D:\\OI\\6.PNG\" alt=\"6.PNG\"></p>\n<p><img src=\"D:\\OI\\7.PNG\" alt=\"7.PNG\"></p>\n<p>然后就可以编代码啦，编译选项我也没找到在哪里改，反正不建议使用</p>\n<h3 id=\"优雅折中的Geany\"><a href=\"#优雅折中的Geany\" class=\"headerlink\" title=\"优雅折中的Geany\"></a>优雅折中的Geany</h3><p>Geany非常简单，打开后和Dev-C++非常相像，只可惜不能调试，只能单开终端调试，可以更改编译选项。</p>\n<p><img src=\"D:\\OI\\8.PNG\" alt=\"8.PNG\"></p>\n<p>更改Build的编译选项即可，可以参照这个来写:</p>\n<pre><code>g++ &quot;%f&quot; -o &quot;%e&quot; -g -Wall -std=c++14 -fsanitize=address,undefined\n</code></pre><p>后面一个神奇的编译选项将在后面提到。调试请参考VSCode的调试部分。</p>\n<h3 id=\"VSCode\"><a href=\"#VSCode\" class=\"headerlink\" title=\"VSCode\"></a>VSCode</h3><p>听说你想用机房很火的VSCode？哈哈，CCF提供的C/C++插件处于半残废状态，要想编译和调试只能手写JSON，反正我不会。</p>\n<p>但是VSCode的代码高亮等等等很好用，只是要手敲命令行，我认为还好。</p>\n<h4 id=\"打开工作区\"><a href=\"#打开工作区\" class=\"headerlink\" title=\"打开工作区\"></a>打开工作区</h4><p>建议直接打开要求的代码保存目录。</p>\n<p><img src=\"D:\\OI\\9.PNG\" alt=\"9.PNG\"></p>\n<h4 id=\"编译及运行\"><a href=\"#编译及运行\" class=\"headerlink\" title=\"编译及运行\"></a>编译及运行</h4><p>在bash终端里面输入</p>\n<pre><code class=\"lang-bash\">g++  *.cpp -o * -g -Wall -std=c++14 -fsanitize=address,undefined\n</code></pre>\n<p>后面的很复杂的编译选项可以不管，这个是新版本g++加入的新功能，可以一定程度上避免程序的UB行为避免大部分RE。</p>\n<p>运行</p>\n<pre><code class=\"lang-bash\">./*\n</code></pre>\n<p>就可以像在Windows下一样输入了，Ctrl+C强制结束。</p>\n<h4 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h4><p>调试功能依赖于gdb。</p>\n<h5 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h5><p>如果此行没有输入命令，按下回车，会自动执行上一行的内容，容易导致翻车</p>\n<h5 id=\"使用指南：\"><a href=\"#使用指南：\" class=\"headerlink\" title=\"使用指南：\"></a>使用指南：</h5><p>进入gdb：</p>\n<pre><code class=\"lang-bash\">gdb *\n</code></pre>\n<p>查看源代码：</p>\n<pre><code class=\"lang-bash\">list\n</code></pre>\n<p>就会列出代码，每次列出 $20$ 行，如果列出，说明可以开始调试，否则编译过程中可能没有加入 -g 选项。</p>\n<p>加入断点：</p>\n<pre><code class=\"lang-bash\">break xxx(行号)\n</code></pre>\n<p>运行：</p>\n<pre><code class=\"lang-bash\">run\n</code></pre>\n<p>下一步：</p>\n<pre><code class=\"lang-bash\">next\n</code></pre>\n<p>单步进入：</p>\n<pre><code class=\"lang-bash\">step\n</code></pre>\n<p>跳过：</p>\n<pre><code class=\"lang-bash\">continue\n</code></pre>\n<p>查看变量值：</p>\n<pre><code class=\"lang-bash\">print xxx(变量名)\n</code></pre>\n<p>应该只会用这些，多余的可以自行了解。</p>\n<p><a href=\"https://blog.csdn.net/qq_28351609/article/details/114855630\">扩展</a></p>\n<h3 id=\"NOI-Linux的其他翻车细节\"><a href=\"#NOI-Linux的其他翻车细节\" class=\"headerlink\" title=\"NOI Linux的其他翻车细节\"></a>NOI Linux的其他翻车细节</h3><h4 id=\"Arbiter\"><a href=\"#Arbiter\" class=\"headerlink\" title=\"Arbiter\"></a>Arbiter</h4><p>arbiter别乱用，特别容易崩溃。</p>\n<h4 id=\"喜闻乐见-jpg\"><a href=\"#喜闻乐见-jpg\" class=\"headerlink\" title=\"喜闻乐见.jpg\"></a>喜闻乐见.jpg</h4><p>scp?</p>\n<p>sshd被删了，别想着偷别人代码。</p>\n<h4 id=\"中文目录\"><a href=\"#中文目录\" class=\"headerlink\" title=\"中文目录\"></a>中文目录</h4><p>哪个zz想的Linux目录是中文啊啊啊，不要把代码复制到桌面，不要给文件名加上中文，否则编译错误满天飞。</p>\n<h4 id=\"编辑器崩溃\"><a href=\"#编辑器崩溃\" class=\"headerlink\" title=\"编辑器崩溃\"></a>编辑器崩溃</h4><p>不建议用编写代码的IDE来看样例，建议单独开一个，大样例会把编辑器搞崩溃，代码就没了。</p>\n"},{"title":"序列解题报告","date":"2023-05-25T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# 序列解题报告\n\n建议到我的博客里食用\n\n### 题意：\n首先定义一个目标序列，称为 $k-$序列：对于序列中的每一项 $s$，序\n列中至少有 $k-1$ 个其他项都等于 $s$。每次操作可以使序列中的任何一项的值减小 $1$。现在给定一个长度为$n$的升序序列和$k$，你的任务是帮OIER们计算出转化为$k-$序列需要的最少步数\n\n换句话来说这个序列中的任意一个数必须有至少k个与他相同的数。\n\n## 苦苦挣扎第一步：\n\n瞄了一眼数据范围,$2 \\leq k \\leq n \\leq 5*10^5$，应该只能是$O(n)或者O(nlogn)$之类的时间复杂度乱搞一下，反过来看一下题序列是已经排好序的，会不会有什么蹊跷呢？贪心？吧每$k$个数字分到一组，通过减把他们全部变成一样的，不幸的是，这样的算法虽然优美，但是是不正确的。只能无奈放弃。\n\n## 苦苦挣扎第二步：\n关于处理序列上的算法无非几个，好像都不能用，只好乱搞一下DP了，因为数据范围巨大，只能开一维dp或者最多加一个$log(n)$，这道题好像也没有要倍增之类的东西，先开成一维，最好想的应该就是前$k$个数是$k-$序列的，根据之前贪心的想法肯定是把数组弄成很多个长度大于等于$k$的连续区间，dp就以当前这个点为后面这个区间的右端点，枚举左端点，动规方程显而易见：\n\n$dp_i=dp_j+sum_i-sum_j-(i-j)*a_{j+1}$ $(k \\leq i)$\n\n$dp_i=inf$ $(i<k)$\n\n## 苦苦挣扎第三步：\n可惜这么好的DP却太慢的，时间复杂度直逼$O(n^2)$，虽然常数较小，但是抵不住 $2 \\leq k \\leq n \\leq 5*10^5$ , 优化！！！\n\n之前的把$O(n^2)$DP优化成$O(n)$需要使用单调队列，要求dp数组有单调性，这道题没有，不行，难道要放弃了吗，还有斜率优化！！！\n\n拆拆大法好!!!：$dp_i=dp_j+sum_i-sum_j-i*a_{j+1}+j*a_{j+1}$\n\n拆完之后再移一下项：$dp_i-sum_i+i*a_{j+1}=dp_j-sum_j+j*a_{j+1}$ $(k \\leq i)$\n\n成功地把与$i$相关的，与$j$相关的，与$i,j$都相关的，分别移到一起，肯定有人问了：这么做干嘛呢，没关系只要这样看这个方程：\n\n$(dp_i-sum_i)+(i)*(a_{j+1})=(dp_j-sum_j+j*a_{j+1})$ $(i>=k)$\n\n$~~~~~~~~~~b~~~~~~~~~~~~~~~~k~~~~~~~~~~x~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~y$\n\n一次函数！！！，平面直角坐标系中有很多与$j$相关的点，相当于过这些点做斜率为$k$的直线交$y$轴与一个点，这个点的纵坐标就是$y$,而$y$就相当于$dp_j$加上很多与$i$相关的常数，因为我们在枚举$i$，所以这些常数是可以确定的，不与$j$相关，接下来就是要求这些交点的纵坐标的最小值。可是怎么优化到$O(1)$求呢，不要慌，慢慢来。\n\n再套一层单调队列，在理解为什么是这样之前先来看看这些点：\n\n样例太小了换一个：\n```\n10 2\n1 3 3 4 5 5 6 7 7 8\n```\n\n结合样例来看当$i=10$是，应该有决策点$8,7,6,5,4,3,2,1,0$，画上坐标轴。（下面有图）\n\n$0,1$是$inf$,所以没画\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wqa19j6l.png)\n\n维护一个有序点集，使得这个点集相邻的两个点相连所得的直线斜率单调递增，这个就是用单调队列优化\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pvs9l1vj.png)\n\n数据没出好，按理说是$n$条线段头尾相接。\n显然的，我们会让相连斜率小于上面$(dp_i-sum_i)+(i)*(a[j+1])=(dp_j-sum_j+j*a_{j+1})$ $(i>=k)$方程中的$k$也就是$i$弹出，因为$i$单调递增，所以后面也不会考虑他，因为$b=y-kx$，斜率太小的话,$x$肯定会很小,$b$就更大了，很显然把这些点去掉之后，\n就选的是最下面那个点，再往上走斜率越大，$y$增长得很快，也不满足最小。\n\n代码就很好写了，注意一个$x$对应多个$y$的情况，这种情况斜率处理成无限大。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#define int long long\ninline int read();\nint a[500005];\nint l,r;\nint sum[500005];\nint que[500005];\nint dp[500005];\ndouble Slope(int r,int l){\n    if(a[r+1]==a[l+1]){\n        return 0x3f3f3f3f3f3f3f3f;\n    }\n    return (double(dp[r]-sum[r]+r*a[r+1]-(dp[l]-sum[l]+l*a[l+1])))/(a[r+1]-a[l+1]);\n}\nsigned main(){\n\t#ifdef ONLINE_JUDGE=LUOGU\n\t#else\n\tfreopen(\"sequence.in\",\"r\",stdin);\n\tfreopen(\"sequence.out\",\"w\",stdout);\n\t#endif\n    int n=read(),k=read();\n    for(int i=1;i<=n;i++){\n        a[i]=read();\n        sum[i]=a[i]+sum[i-1];\n    }\n    que[0]=-1;  \n    for(int i=1;i<=n;i++){\n        if(i-k>=0){\n            while(l<r&&Slope(que[r-1],que[r])>=Slope(que[r],i-k)){\n                r--;\n            }\n            que[++r]=i-k;\n        }\n        while(l<r&&Slope(que[l],que[l+1])<=i){\n            l++;\n        }\n        int j=que[l];\n        if(i-k<0){\n            dp[i]=0x3f3f3f3f3f3f3f3f;\n        }else if(j!=-1){\n            dp[i]=dp[j]+(sum[i]-sum[j])-(i-j)*a[j+1];\n        }else\n            dp[i]=(sum[i])-(i-j)*a[j+1];\n    }\n    printf(\"%lld\",dp[n]);\n\treturn 0;\n}\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tc=='-'?f=-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n\t1:\n\t\tIn:\n\n\t\tOut:\nMore:\n\n*/\n\n\n```\n\n作者懒癌晚期，前两个非正解不想写代码了，希望各位理解\n","source":"_posts/0006.md","raw":"---\ntitle: 序列解题报告\ndate: 2023-05-26\ntags: [OI]\ntoc: true\nmathjax: true\n---\n\n# 序列解题报告\n\n建议到我的博客里食用\n\n### 题意：\n首先定义一个目标序列，称为 $k-$序列：对于序列中的每一项 $s$，序\n列中至少有 $k-1$ 个其他项都等于 $s$。每次操作可以使序列中的任何一项的值减小 $1$。现在给定一个长度为$n$的升序序列和$k$，你的任务是帮OIER们计算出转化为$k-$序列需要的最少步数\n\n换句话来说这个序列中的任意一个数必须有至少k个与他相同的数。\n\n## 苦苦挣扎第一步：\n\n瞄了一眼数据范围,$2 \\leq k \\leq n \\leq 5*10^5$，应该只能是$O(n)或者O(nlogn)$之类的时间复杂度乱搞一下，反过来看一下题序列是已经排好序的，会不会有什么蹊跷呢？贪心？吧每$k$个数字分到一组，通过减把他们全部变成一样的，不幸的是，这样的算法虽然优美，但是是不正确的。只能无奈放弃。\n\n## 苦苦挣扎第二步：\n关于处理序列上的算法无非几个，好像都不能用，只好乱搞一下DP了，因为数据范围巨大，只能开一维dp或者最多加一个$log(n)$，这道题好像也没有要倍增之类的东西，先开成一维，最好想的应该就是前$k$个数是$k-$序列的，根据之前贪心的想法肯定是把数组弄成很多个长度大于等于$k$的连续区间，dp就以当前这个点为后面这个区间的右端点，枚举左端点，动规方程显而易见：\n\n$dp_i=dp_j+sum_i-sum_j-(i-j)*a_{j+1}$ $(k \\leq i)$\n\n$dp_i=inf$ $(i<k)$\n\n## 苦苦挣扎第三步：\n可惜这么好的DP却太慢的，时间复杂度直逼$O(n^2)$，虽然常数较小，但是抵不住 $2 \\leq k \\leq n \\leq 5*10^5$ , 优化！！！\n\n之前的把$O(n^2)$DP优化成$O(n)$需要使用单调队列，要求dp数组有单调性，这道题没有，不行，难道要放弃了吗，还有斜率优化！！！\n\n拆拆大法好!!!：$dp_i=dp_j+sum_i-sum_j-i*a_{j+1}+j*a_{j+1}$\n\n拆完之后再移一下项：$dp_i-sum_i+i*a_{j+1}=dp_j-sum_j+j*a_{j+1}$ $(k \\leq i)$\n\n成功地把与$i$相关的，与$j$相关的，与$i,j$都相关的，分别移到一起，肯定有人问了：这么做干嘛呢，没关系只要这样看这个方程：\n\n$(dp_i-sum_i)+(i)*(a_{j+1})=(dp_j-sum_j+j*a_{j+1})$ $(i>=k)$\n\n$~~~~~~~~~~b~~~~~~~~~~~~~~~~k~~~~~~~~~~x~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~y$\n\n一次函数！！！，平面直角坐标系中有很多与$j$相关的点，相当于过这些点做斜率为$k$的直线交$y$轴与一个点，这个点的纵坐标就是$y$,而$y$就相当于$dp_j$加上很多与$i$相关的常数，因为我们在枚举$i$，所以这些常数是可以确定的，不与$j$相关，接下来就是要求这些交点的纵坐标的最小值。可是怎么优化到$O(1)$求呢，不要慌，慢慢来。\n\n再套一层单调队列，在理解为什么是这样之前先来看看这些点：\n\n样例太小了换一个：\n```\n10 2\n1 3 3 4 5 5 6 7 7 8\n```\n\n结合样例来看当$i=10$是，应该有决策点$8,7,6,5,4,3,2,1,0$，画上坐标轴。（下面有图）\n\n$0,1$是$inf$,所以没画\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wqa19j6l.png)\n\n维护一个有序点集，使得这个点集相邻的两个点相连所得的直线斜率单调递增，这个就是用单调队列优化\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pvs9l1vj.png)\n\n数据没出好，按理说是$n$条线段头尾相接。\n显然的，我们会让相连斜率小于上面$(dp_i-sum_i)+(i)*(a[j+1])=(dp_j-sum_j+j*a_{j+1})$ $(i>=k)$方程中的$k$也就是$i$弹出，因为$i$单调递增，所以后面也不会考虑他，因为$b=y-kx$，斜率太小的话,$x$肯定会很小,$b$就更大了，很显然把这些点去掉之后，\n就选的是最下面那个点，再往上走斜率越大，$y$增长得很快，也不满足最小。\n\n代码就很好写了，注意一个$x$对应多个$y$的情况，这种情况斜率处理成无限大。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#define int long long\ninline int read();\nint a[500005];\nint l,r;\nint sum[500005];\nint que[500005];\nint dp[500005];\ndouble Slope(int r,int l){\n    if(a[r+1]==a[l+1]){\n        return 0x3f3f3f3f3f3f3f3f;\n    }\n    return (double(dp[r]-sum[r]+r*a[r+1]-(dp[l]-sum[l]+l*a[l+1])))/(a[r+1]-a[l+1]);\n}\nsigned main(){\n\t#ifdef ONLINE_JUDGE=LUOGU\n\t#else\n\tfreopen(\"sequence.in\",\"r\",stdin);\n\tfreopen(\"sequence.out\",\"w\",stdout);\n\t#endif\n    int n=read(),k=read();\n    for(int i=1;i<=n;i++){\n        a[i]=read();\n        sum[i]=a[i]+sum[i-1];\n    }\n    que[0]=-1;  \n    for(int i=1;i<=n;i++){\n        if(i-k>=0){\n            while(l<r&&Slope(que[r-1],que[r])>=Slope(que[r],i-k)){\n                r--;\n            }\n            que[++r]=i-k;\n        }\n        while(l<r&&Slope(que[l],que[l+1])<=i){\n            l++;\n        }\n        int j=que[l];\n        if(i-k<0){\n            dp[i]=0x3f3f3f3f3f3f3f3f;\n        }else if(j!=-1){\n            dp[i]=dp[j]+(sum[i]-sum[j])-(i-j)*a[j+1];\n        }else\n            dp[i]=(sum[i])-(i-j)*a[j+1];\n    }\n    printf(\"%lld\",dp[n]);\n\treturn 0;\n}\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tc=='-'?f=-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n\t1:\n\t\tIn:\n\n\t\tOut:\nMore:\n\n*/\n\n\n```\n\n作者懒癌晚期，前两个非正解不想写代码了，希望各位理解\n","slug":"0006","published":1,"updated":"2024-01-08T11:16:24.591Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65tf0007rqayfv44fmei","content":"<h1 id=\"序列解题报告\"><a href=\"#序列解题报告\" class=\"headerlink\" title=\"序列解题报告\"></a>序列解题报告</h1><p>建议到我的博客里食用</p>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>首先定义一个目标序列，称为 $k-$序列：对于序列中的每一项 $s$，序<br>列中至少有 $k-1$ 个其他项都等于 $s$。每次操作可以使序列中的任何一项的值减小 $1$。现在给定一个长度为$n$的升序序列和$k$，你的任务是帮OIER们计算出转化为$k-$序列需要的最少步数</p>\n<p>换句话来说这个序列中的任意一个数必须有至少k个与他相同的数。</p>\n<h2 id=\"苦苦挣扎第一步：\"><a href=\"#苦苦挣扎第一步：\" class=\"headerlink\" title=\"苦苦挣扎第一步：\"></a>苦苦挣扎第一步：</h2><p>瞄了一眼数据范围,$2 \\leq k \\leq n \\leq 5*10^5$，应该只能是$O(n)或者O(nlogn)$之类的时间复杂度乱搞一下，反过来看一下题序列是已经排好序的，会不会有什么蹊跷呢？贪心？吧每$k$个数字分到一组，通过减把他们全部变成一样的，不幸的是，这样的算法虽然优美，但是是不正确的。只能无奈放弃。</p>\n<h2 id=\"苦苦挣扎第二步：\"><a href=\"#苦苦挣扎第二步：\" class=\"headerlink\" title=\"苦苦挣扎第二步：\"></a>苦苦挣扎第二步：</h2><p>关于处理序列上的算法无非几个，好像都不能用，只好乱搞一下DP了，因为数据范围巨大，只能开一维dp或者最多加一个$log(n)$，这道题好像也没有要倍增之类的东西，先开成一维，最好想的应该就是前$k$个数是$k-$序列的，根据之前贪心的想法肯定是把数组弄成很多个长度大于等于$k$的连续区间，dp就以当前这个点为后面这个区间的右端点，枚举左端点，动规方程显而易见：</p>\n<p>$dp_i=dp_j+sum_i-sum_j-(i-j)*a_{j+1}$ $(k \\leq i)$</p>\n<p>$dp_i=inf$ $(i&lt;k)$</p>\n<h2 id=\"苦苦挣扎第三步：\"><a href=\"#苦苦挣扎第三步：\" class=\"headerlink\" title=\"苦苦挣扎第三步：\"></a>苦苦挣扎第三步：</h2><p>可惜这么好的DP却太慢的，时间复杂度直逼$O(n^2)$，虽然常数较小，但是抵不住 $2 \\leq k \\leq n \\leq 5*10^5$ , 优化！！！</p>\n<p>之前的把$O(n^2)$DP优化成$O(n)$需要使用单调队列，要求dp数组有单调性，这道题没有，不行，难道要放弃了吗，还有斜率优化！！！</p>\n<p>拆拆大法好!!!：$dp_i=dp_j+sum_i-sum_j-i<em>a_{j+1}+j</em>a_{j+1}$</p>\n<p>拆完之后再移一下项：$dp_i-sum_i+i<em>a_{j+1}=dp_j-sum_j+j</em>a_{j+1}$ $(k \\leq i)$</p>\n<p>成功地把与$i$相关的，与$j$相关的，与$i,j$都相关的，分别移到一起，肯定有人问了：这么做干嘛呢，没关系只要这样看这个方程：</p>\n<p>$(dp_i-sum_i)+(i)<em>(a_{j+1})=(dp_j-sum_j+j</em>a_{j+1})$ $(i&gt;=k)$</p>\n<p>$<del>~</del><del>~</del>b<del>~</del><del>~</del><del>~</del>~k<del>~</del><del>~</del>x<del>~</del><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del>~y$</p>\n<p>一次函数！！！，平面直角坐标系中有很多与$j$相关的点，相当于过这些点做斜率为$k$的直线交$y$轴与一个点，这个点的纵坐标就是$y$,而$y$就相当于$dp_j$加上很多与$i$相关的常数，因为我们在枚举$i$，所以这些常数是可以确定的，不与$j$相关，接下来就是要求这些交点的纵坐标的最小值。可是怎么优化到$O(1)$求呢，不要慌，慢慢来。</p>\n<p>再套一层单调队列，在理解为什么是这样之前先来看看这些点：</p>\n<p>样例太小了换一个：</p>\n<pre><code>10 2\n1 3 3 4 5 5 6 7 7 8\n</code></pre><p>结合样例来看当$i=10$是，应该有决策点$8,7,6,5,4,3,2,1,0$，画上坐标轴。（下面有图）</p>\n<p>$0,1$是$inf$,所以没画</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/wqa19j6l.png\" alt=\"\"></p>\n<p>维护一个有序点集，使得这个点集相邻的两个点相连所得的直线斜率单调递增，这个就是用单调队列优化</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/pvs9l1vj.png\" alt=\"\"></p>\n<p>数据没出好，按理说是$n$条线段头尾相接。<br>显然的，我们会让相连斜率小于上面$(dp_i-sum_i)+(i)<em>(a[j+1])=(dp_j-sum_j+j</em>a_{j+1})$ $(i&gt;=k)$方程中的$k$也就是$i$弹出，因为$i$单调递增，所以后面也不会考虑他，因为$b=y-kx$，斜率太小的话,$x$肯定会很小,$b$就更大了，很显然把这些点去掉之后，<br>就选的是最下面那个点，再往上走斜率越大，$y$增长得很快，也不满足最小。</p>\n<p>代码就很好写了，注意一个$x$对应多个$y$的情况，这种情况斜率处理成无限大。</p>\n<pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define int long long\ninline int read();\nint a[500005];\nint l,r;\nint sum[500005];\nint que[500005];\nint dp[500005];\ndouble Slope(int r,int l)&#123;\n    if(a[r+1]==a[l+1])&#123;\n        return 0x3f3f3f3f3f3f3f3f;\n    &#125;\n    return (double(dp[r]-sum[r]+r*a[r+1]-(dp[l]-sum[l]+l*a[l+1])))/(a[r+1]-a[l+1]);\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE=LUOGU\n    #else\n    freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),k=read();\n    for(int i=1;i&lt;=n;i++)&#123;\n        a[i]=read();\n        sum[i]=a[i]+sum[i-1];\n    &#125;\n    que[0]=-1;  \n    for(int i=1;i&lt;=n;i++)&#123;\n        if(i-k&gt;=0)&#123;\n            while(l&lt;r&amp;&amp;Slope(que[r-1],que[r])&gt;=Slope(que[r],i-k))&#123;\n                r--;\n            &#125;\n            que[++r]=i-k;\n        &#125;\n        while(l&lt;r&amp;&amp;Slope(que[l],que[l+1])&lt;=i)&#123;\n            l++;\n        &#125;\n        int j=que[l];\n        if(i-k&lt;0)&#123;\n            dp[i]=0x3f3f3f3f3f3f3f3f;\n        &#125;else if(j!=-1)&#123;\n            dp[i]=dp[j]+(sum[i]-sum[j])-(i-j)*a[j+1];\n        &#125;else\n            dp[i]=(sum[i])-(i-j)*a[j+1];\n    &#125;\n    printf(&quot;%lld&quot;,dp[n]);\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n<p>作者懒癌晚期，前两个非正解不想写代码了，希望各位理解</p>\n","excerpt":"","more":"<h1 id=\"序列解题报告\"><a href=\"#序列解题报告\" class=\"headerlink\" title=\"序列解题报告\"></a>序列解题报告</h1><p>建议到我的博客里食用</p>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>首先定义一个目标序列，称为 $k-$序列：对于序列中的每一项 $s$，序<br>列中至少有 $k-1$ 个其他项都等于 $s$。每次操作可以使序列中的任何一项的值减小 $1$。现在给定一个长度为$n$的升序序列和$k$，你的任务是帮OIER们计算出转化为$k-$序列需要的最少步数</p>\n<p>换句话来说这个序列中的任意一个数必须有至少k个与他相同的数。</p>\n<h2 id=\"苦苦挣扎第一步：\"><a href=\"#苦苦挣扎第一步：\" class=\"headerlink\" title=\"苦苦挣扎第一步：\"></a>苦苦挣扎第一步：</h2><p>瞄了一眼数据范围,$2 \\leq k \\leq n \\leq 5*10^5$，应该只能是$O(n)或者O(nlogn)$之类的时间复杂度乱搞一下，反过来看一下题序列是已经排好序的，会不会有什么蹊跷呢？贪心？吧每$k$个数字分到一组，通过减把他们全部变成一样的，不幸的是，这样的算法虽然优美，但是是不正确的。只能无奈放弃。</p>\n<h2 id=\"苦苦挣扎第二步：\"><a href=\"#苦苦挣扎第二步：\" class=\"headerlink\" title=\"苦苦挣扎第二步：\"></a>苦苦挣扎第二步：</h2><p>关于处理序列上的算法无非几个，好像都不能用，只好乱搞一下DP了，因为数据范围巨大，只能开一维dp或者最多加一个$log(n)$，这道题好像也没有要倍增之类的东西，先开成一维，最好想的应该就是前$k$个数是$k-$序列的，根据之前贪心的想法肯定是把数组弄成很多个长度大于等于$k$的连续区间，dp就以当前这个点为后面这个区间的右端点，枚举左端点，动规方程显而易见：</p>\n<p>$dp_i=dp_j+sum_i-sum_j-(i-j)*a_{j+1}$ $(k \\leq i)$</p>\n<p>$dp_i=inf$ $(i&lt;k)$</p>\n<h2 id=\"苦苦挣扎第三步：\"><a href=\"#苦苦挣扎第三步：\" class=\"headerlink\" title=\"苦苦挣扎第三步：\"></a>苦苦挣扎第三步：</h2><p>可惜这么好的DP却太慢的，时间复杂度直逼$O(n^2)$，虽然常数较小，但是抵不住 $2 \\leq k \\leq n \\leq 5*10^5$ , 优化！！！</p>\n<p>之前的把$O(n^2)$DP优化成$O(n)$需要使用单调队列，要求dp数组有单调性，这道题没有，不行，难道要放弃了吗，还有斜率优化！！！</p>\n<p>拆拆大法好!!!：$dp_i=dp_j+sum_i-sum_j-i<em>a_{j+1}+j</em>a_{j+1}$</p>\n<p>拆完之后再移一下项：$dp_i-sum_i+i<em>a_{j+1}=dp_j-sum_j+j</em>a_{j+1}$ $(k \\leq i)$</p>\n<p>成功地把与$i$相关的，与$j$相关的，与$i,j$都相关的，分别移到一起，肯定有人问了：这么做干嘛呢，没关系只要这样看这个方程：</p>\n<p>$(dp_i-sum_i)+(i)<em>(a_{j+1})=(dp_j-sum_j+j</em>a_{j+1})$ $(i&gt;=k)$</p>\n<p>$<del>~</del><del>~</del>b<del>~</del><del>~</del><del>~</del>~k<del>~</del><del>~</del>x<del>~</del><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del>~y$</p>\n<p>一次函数！！！，平面直角坐标系中有很多与$j$相关的点，相当于过这些点做斜率为$k$的直线交$y$轴与一个点，这个点的纵坐标就是$y$,而$y$就相当于$dp_j$加上很多与$i$相关的常数，因为我们在枚举$i$，所以这些常数是可以确定的，不与$j$相关，接下来就是要求这些交点的纵坐标的最小值。可是怎么优化到$O(1)$求呢，不要慌，慢慢来。</p>\n<p>再套一层单调队列，在理解为什么是这样之前先来看看这些点：</p>\n<p>样例太小了换一个：</p>\n<pre><code>10 2\n1 3 3 4 5 5 6 7 7 8\n</code></pre><p>结合样例来看当$i=10$是，应该有决策点$8,7,6,5,4,3,2,1,0$，画上坐标轴。（下面有图）</p>\n<p>$0,1$是$inf$,所以没画</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/wqa19j6l.png\" alt=\"\"></p>\n<p>维护一个有序点集，使得这个点集相邻的两个点相连所得的直线斜率单调递增，这个就是用单调队列优化</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/pvs9l1vj.png\" alt=\"\"></p>\n<p>数据没出好，按理说是$n$条线段头尾相接。<br>显然的，我们会让相连斜率小于上面$(dp_i-sum_i)+(i)<em>(a[j+1])=(dp_j-sum_j+j</em>a_{j+1})$ $(i&gt;=k)$方程中的$k$也就是$i$弹出，因为$i$单调递增，所以后面也不会考虑他，因为$b=y-kx$，斜率太小的话,$x$肯定会很小,$b$就更大了，很显然把这些点去掉之后，<br>就选的是最下面那个点，再往上走斜率越大，$y$增长得很快，也不满足最小。</p>\n<p>代码就很好写了，注意一个$x$对应多个$y$的情况，这种情况斜率处理成无限大。</p>\n<pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define int long long\ninline int read();\nint a[500005];\nint l,r;\nint sum[500005];\nint que[500005];\nint dp[500005];\ndouble Slope(int r,int l)&#123;\n    if(a[r+1]==a[l+1])&#123;\n        return 0x3f3f3f3f3f3f3f3f;\n    &#125;\n    return (double(dp[r]-sum[r]+r*a[r+1]-(dp[l]-sum[l]+l*a[l+1])))/(a[r+1]-a[l+1]);\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE=LUOGU\n    #else\n    freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),k=read();\n    for(int i=1;i&lt;=n;i++)&#123;\n        a[i]=read();\n        sum[i]=a[i]+sum[i-1];\n    &#125;\n    que[0]=-1;  \n    for(int i=1;i&lt;=n;i++)&#123;\n        if(i-k&gt;=0)&#123;\n            while(l&lt;r&amp;&amp;Slope(que[r-1],que[r])&gt;=Slope(que[r],i-k))&#123;\n                r--;\n            &#125;\n            que[++r]=i-k;\n        &#125;\n        while(l&lt;r&amp;&amp;Slope(que[l],que[l+1])&lt;=i)&#123;\n            l++;\n        &#125;\n        int j=que[l];\n        if(i-k&lt;0)&#123;\n            dp[i]=0x3f3f3f3f3f3f3f3f;\n        &#125;else if(j!=-1)&#123;\n            dp[i]=dp[j]+(sum[i]-sum[j])-(i-j)*a[j+1];\n        &#125;else\n            dp[i]=(sum[i])-(i-j)*a[j+1];\n    &#125;\n    printf(&quot;%lld&quot;,dp[n]);\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n<p>作者懒癌晚期，前两个非正解不想写代码了，希望各位理解</p>\n"},{"title":"网络流随笔","date":"2024-01-02T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n最大流：\n\n常用于有奇奇怪怪约束条件的最大值问题，可输出方案。\n\n最小割：\n\n约束条件为满足 A 则不能满足 B 此类的最小值问题。\n\n也可以解决图论上与割有关的问题。\n\n具有阶段的问题可以分层。\n\n删边的操作一般对应满足某条件。\n\n费用流：\n\n在满足所有奇奇怪怪的约束条件下，代价最小\n","source":"_posts/0007.md","raw":"---\ntitle: 网络流随笔\ndate: 2024-01-03\ntags: [OI,网络流]\ntoc: true\nmathjax: true\n---\n\n最大流：\n\n常用于有奇奇怪怪约束条件的最大值问题，可输出方案。\n\n最小割：\n\n约束条件为满足 A 则不能满足 B 此类的最小值问题。\n\n也可以解决图论上与割有关的问题。\n\n具有阶段的问题可以分层。\n\n删边的操作一般对应满足某条件。\n\n费用流：\n\n在满足所有奇奇怪怪的约束条件下，代价最小\n","slug":"0007","published":1,"updated":"2024-01-08T11:18:19.806Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65th0008rqay3lqugmln","content":"<p>最大流：</p>\n<p>常用于有奇奇怪怪约束条件的最大值问题，可输出方案。</p>\n<p>最小割：</p>\n<p>约束条件为满足 A 则不能满足 B 此类的最小值问题。</p>\n<p>也可以解决图论上与割有关的问题。</p>\n<p>具有阶段的问题可以分层。</p>\n<p>删边的操作一般对应满足某条件。</p>\n<p>费用流：</p>\n<p>在满足所有奇奇怪怪的约束条件下，代价最小</p>\n","excerpt":"","more":"<p>最大流：</p>\n<p>常用于有奇奇怪怪约束条件的最大值问题，可输出方案。</p>\n<p>最小割：</p>\n<p>约束条件为满足 A 则不能满足 B 此类的最小值问题。</p>\n<p>也可以解决图论上与割有关的问题。</p>\n<p>具有阶段的问题可以分层。</p>\n<p>删边的操作一般对应满足某条件。</p>\n<p>费用流：</p>\n<p>在满足所有奇奇怪怪的约束条件下，代价最小</p>\n"},{"title":"摸鱼记录","date":"2024-01-02T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n\n# 12.29\n## 上午\n模拟赛，切了T1，T2，感觉是简单题，不过做题策略（手推样例）对分数及时间起了很大作用。\n\nT3看题解也有点抽象，算了，摆。\n\nT4人类智慧出现了，希望有人给出严谨证明。\n\n## 下午\n\n14:00-15:00 看邮件\n\n15:00-17:00 写题，只写了一道，低级错误太多了。\n\n## 晚上\n\n吃火锅去了\n\n# 12.30\n\n## 上午\n\n写了2道题，一堆人跑去班上玩去了，看了看github\n\n# 1.2\n\n## 上午\n\n模拟赛，T3文件名 `ex_grand2.in`\n\n## 下午\n\n补模拟赛\n\n# 1.3\n\n费用流\n\n#1.4\n\n## 上午\n\n模拟赛\n\n## 下午\n\n看了2h+,看不懂题解，最后看了看实现又看懂了，不想写。费用流去了。\n\n","source":"_posts/0008.md","raw":"---\ntitle: 摸鱼记录\ndate: 2024-01-03\ntags: [OI]\ntoc: true\nmathjax: true\n---\n\n\n# 12.29\n## 上午\n模拟赛，切了T1，T2，感觉是简单题，不过做题策略（手推样例）对分数及时间起了很大作用。\n\nT3看题解也有点抽象，算了，摆。\n\nT4人类智慧出现了，希望有人给出严谨证明。\n\n## 下午\n\n14:00-15:00 看邮件\n\n15:00-17:00 写题，只写了一道，低级错误太多了。\n\n## 晚上\n\n吃火锅去了\n\n# 12.30\n\n## 上午\n\n写了2道题，一堆人跑去班上玩去了，看了看github\n\n# 1.2\n\n## 上午\n\n模拟赛，T3文件名 `ex_grand2.in`\n\n## 下午\n\n补模拟赛\n\n# 1.3\n\n费用流\n\n#1.4\n\n## 上午\n\n模拟赛\n\n## 下午\n\n看了2h+,看不懂题解，最后看了看实现又看懂了，不想写。费用流去了。\n\n","slug":"0008","published":1,"updated":"2024-01-08T11:19:37.080Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65tq000arqaydgpdejjd","content":"<h1 id=\"12-29\"><a href=\"#12-29\" class=\"headerlink\" title=\"12.29\"></a>12.29</h1><h2 id=\"上午\"><a href=\"#上午\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛，切了T1，T2，感觉是简单题，不过做题策略（手推样例）对分数及时间起了很大作用。</p>\n<p>T3看题解也有点抽象，算了，摆。</p>\n<p>T4人类智慧出现了，希望有人给出严谨证明。</p>\n<h2 id=\"下午\"><a href=\"#下午\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>14:00-15:00 看邮件</p>\n<p>15:00-17:00 写题，只写了一道，低级错误太多了。</p>\n<h2 id=\"晚上\"><a href=\"#晚上\" class=\"headerlink\" title=\"晚上\"></a>晚上</h2><p>吃火锅去了</p>\n<h1 id=\"12-30\"><a href=\"#12-30\" class=\"headerlink\" title=\"12.30\"></a>12.30</h1><h2 id=\"上午-1\"><a href=\"#上午-1\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>写了2道题，一堆人跑去班上玩去了，看了看github</p>\n<h1 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1.2\"></a>1.2</h1><h2 id=\"上午-2\"><a href=\"#上午-2\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛，T3文件名 <code>ex_grand2.in</code></p>\n<h2 id=\"下午-1\"><a href=\"#下午-1\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>补模拟赛</p>\n<h1 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1.3\"></a>1.3</h1><p>费用流</p>\n<h1 id=\"1-4\"><a href=\"#1-4\" class=\"headerlink\" title=\"1.4\"></a>1.4</h1><h2 id=\"上午-3\"><a href=\"#上午-3\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛</p>\n<h2 id=\"下午-2\"><a href=\"#下午-2\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>看了2h+,看不懂题解，最后看了看实现又看懂了，不想写。费用流去了。</p>\n","excerpt":"","more":"<h1 id=\"12-29\"><a href=\"#12-29\" class=\"headerlink\" title=\"12.29\"></a>12.29</h1><h2 id=\"上午\"><a href=\"#上午\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛，切了T1，T2，感觉是简单题，不过做题策略（手推样例）对分数及时间起了很大作用。</p>\n<p>T3看题解也有点抽象，算了，摆。</p>\n<p>T4人类智慧出现了，希望有人给出严谨证明。</p>\n<h2 id=\"下午\"><a href=\"#下午\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>14:00-15:00 看邮件</p>\n<p>15:00-17:00 写题，只写了一道，低级错误太多了。</p>\n<h2 id=\"晚上\"><a href=\"#晚上\" class=\"headerlink\" title=\"晚上\"></a>晚上</h2><p>吃火锅去了</p>\n<h1 id=\"12-30\"><a href=\"#12-30\" class=\"headerlink\" title=\"12.30\"></a>12.30</h1><h2 id=\"上午-1\"><a href=\"#上午-1\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>写了2道题，一堆人跑去班上玩去了，看了看github</p>\n<h1 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1.2\"></a>1.2</h1><h2 id=\"上午-2\"><a href=\"#上午-2\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛，T3文件名 <code>ex_grand2.in</code></p>\n<h2 id=\"下午-1\"><a href=\"#下午-1\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>补模拟赛</p>\n<h1 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1.3\"></a>1.3</h1><p>费用流</p>\n<h1 id=\"1-4\"><a href=\"#1-4\" class=\"headerlink\" title=\"1.4\"></a>1.4</h1><h2 id=\"上午-3\"><a href=\"#上午-3\" class=\"headerlink\" title=\"上午\"></a>上午</h2><p>模拟赛</p>\n<h2 id=\"下午-2\"><a href=\"#下午-2\" class=\"headerlink\" title=\"下午\"></a>下午</h2><p>看了2h+,看不懂题解，最后看了看实现又看懂了，不想写。费用流去了。</p>\n"},{"title":"浅谈OIer的NVIM配置","date":"2023-08-22T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n# 浅谈OIer的NVIM配置\n\n\n本文因跨平台、软件版本更新等不可控因素，部分内容可能失效，请联系我修改！\n\n## 懒者专用\n\n不建议直接使用！因为路径产生的 BUG 可能很多！\n\n我的配置文件仓库：[wxt1221-NvChad](https://github.com/wxt1221/wxt1221-NvChad)\n\n\n## 前言\n\n某某人在机房配好 Vscode 之后发现卡死了，所以准备用 vim 写代码！\n\n但是网上资料太少了，特别是针对 OIer 刷题的配置，所以我就来了。\n\n上效果图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fd9wcynp.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z81xs7cv.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hymt7myx.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gsvsinza.png)\n\n## 软件选择\n\n原版 Vim 其实并不好，主要有几点。\n\n- 众所周知开屏有些敏感话题\n  \n- 不好配\n  \n\n不过，Vim 的分支多得很，看了一圈决定是 Nvim！\n\n## 安装\n\nLinux 下的话到你自己发行版的库里面找找就是了。\n\nWindows的话有 qnvim，也就是基于 Qt 的。\n\n## 配置\n\nNvim 打开还是和 Vim 差不多，但是真正好用的是网上打包好的配置文件！\n\n隆重推荐 NvChad！（在 github 上有超 1w 的 star）\n\n[NvChad/NvChad](https://github.com/NvChad/NvChad)\n\n安装很简单，在本项目的官网上有详细介绍不同平台的方法\n\n[Link](https://nvchad.com/docs/quickstart/install)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hjq5ehv8.png)\n\n另外还有字体的问题，建议使用带 Nerd 字样的字体，~~我用的是 JetBrains Mono Nerd Font ，应该是没有问题的~~，~~不要用这个字体，Nerd Font 不全，FiraCode 和 JetBrains Mono 风格差不多~~，都有bug！烦死了！，可以先安装 JetBrains Mono 字体，再安装这个：[Link](https://github.com/wangrunlin/nerd-font-JetBrains-windows)，至于怎么换，这个在各个平台上不同，大概率都是你的终端的配置文件里面可以改。\n\n## Vim相关\n\nVim 和普通的文本编辑器有很大不同，Vim 的宗旨之一就是能在不碰鼠标的情况下实现很多功能，为了能够容下更多操作，所以 Vim 其实是有模式区分的。\n\n最常用的是普通模式，在这个模式下可以通过输入冒号进入命令模式。\n\n还有编辑模式，这个模式顾名思义就是可以编辑文件，按 esc 退出到普通模式。\n\n命令模式就是输入命令的，这个是 Vim 单独的一套命令，不是 bash，同样是按 esc 退出到普通模式。\n\n## 常用快捷键\n\n[Neovim的常见快捷键和命令 - 掘金](https://juejin.cn/post/7084462939595341831)\n\n可以参考这篇。\n\n主要是要记住窗口相关的和 tree 相关的。\n\n## 继续配置\n\n然而你发现 NvChad 不能编译运行调试，好难受，~~马上回到 Vscode~~。\n\n其实是可以的，运行和调试是一个东西，所以先说。\n\n调试依赖于 DAP。\n\nNvim 上最好用的 DAP 就是 nvim-dap ，经过了很久的折腾后，终于找到了方法！\n\n要装一堆插件，进入配置文件夹，Linux在`~/.config/nvim` ，Windows在`$HOME\\AppData\\Local\\nvim` ，里面有一个 `lua` 文件夹打开，进入 `plugins` 文件夹 ，打开 `init.lua` 开始编辑。\n\n这个文件是 Nvim 的包管理器，注意到定义了一个 `default_plugins` 直接在这里面改就行了，加入这些插件：\n\n```\n  {\"nvim-telescope/telescope.nvim\",lazy=false},\n  {\"ravenxrz/DAPInstall.nvim\",lazy=false},\n  {\"mfussenegger/nvim-dap\",lazy=false},\n  {\"rcarriga/nvim-dap-ui\",lazy=false},\n  {\"theHamsta/nvim-dap-virtual-text\",lazy=false},\n```\n\n然后退出重进，不出意外就开始下包了。\n\n这里有一个非常 NTR 的事情，就是我们又要用 Vscode 的东西了，这次使用 Vscode 的调试工具！\n\n按冒号进入命令行模式开始安装\n\n```\n:DIInstall ccppr_vsc\n```\n\n就开始跑命令安装了，等到出现了类似于`Process exited` 的字样就说明成功了。\n\n还没结束，接下来才是真正的极客！\n\n在之前打开过的 `plugins` 文件夹里面有一个 `configs`文件夹，建立新文件夹 `dap` 用于写配置文件\n\n`dap/icon.lua`\n\n```lua\nlocal M={}\nfunction M.setup()\n\tlocal dap_breakpoint = {\n\t\tbreakpoint = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignError\",\n\t\t\tlinehl = \"\",\n\t\t\tnumhl = \"\",\n\t\t},\n\t\trejected = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignHint\",\n\t\t\tlinehl = \"\",\n\t\t\tnumhl = \"\",\n\t\t},\n\t\tstopped = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignInformation\",\n\t\t\tlinehl = \"DiagnosticUnderlineInfo\",\n\t\t\tnumhl = \"LspDiagnosticsSignInformation\",\n\t\t},\n\t}\n\n\tvim.fn.sign_define(\"DapBreakpoint\", dap_breakpoint.breakpoint)\n\tvim.fn.sign_define(\"DapStopped\", dap_breakpoint.stopped)\n\tvim.fn.sign_define(\"DapBreakpointRejected\", dap_breakpoint.rejected)\nend\nreturn M\n```\n\ndap/init.lua\n\n```lua\nlocal M = {}\n\nlocal function configure()\nend\n\nlocal function configure_exts()\nend\n\nlocal function configure_debuggers()\nend\n\nfunction M.setup()\n\tconfigure() -- Configuration\n\tconfigure_exts() -- Extensions\n\tconfigure_debuggers() -- Debugger\n  require(\"plugins.configs.dap.keymap\").setup()\n  require(\"plugins.configs.dap.ui\").setup()\n  require(\"plugins.configs.dap.icon\").setup()\n  require(\"dap.ext.vscode\").load_launchjs(nil, { cppdbg = { \"c\", \"cpp\", \"rust\" } })\n  local dap = require('dap')\n  dap.adapters.cppdbg = {\n    id = 'cppdbg',\n    type = 'executable',\n    command = '/home/wxt/.local/share/nvim/dapinstall/ccppr_vsc/extension/debugAdapters/bin/OpenDebugAD7',\n  }\nend\n\nconfigure_debuggers()\n\nreturn M\n```\n\ndap/keymap.lua\n\n```lua\nlocal M = {}\n\nlocal whichkey = require \"which-key\"\n-- local legendary = require \"legendary\"\n\n-- local function keymap(lhs, rhs, desc)\n--   vim.keymap.set(\"n\", lhs, rhs, { silent = true, desc = desc })\n-- end\n\nfunction M.setup()\n  local keymap = {\n    l = {\n      name = \"DAP\",\n      R = { \"<cmd>lua require'dap'.run_to_cursor()<cr>\", \"Run to Cursor\" },\n      E = { \"<cmd>lua require'dapui'.eval(vim.fn.input '[Expression] > ')<cr>\", \"Evaluate Input\" },\n      C = { \"<cmd>lua require'dap'.set_breakpoint(vim.fn.input '[Condition] > ')<cr>\", \"Conditional Breakpoint\" },\n      U = { \"<cmd>lua require'dapui'.toggle()<cr>\", \"Toggle UI\" },\n      b = { \"<cmd>lua require'dap'.step_back()<cr>\", \"Step Back\" },\n      c = { \"<cmd>lua require'dap'.continue()<cr>\", \"Continue\" },\n      d = { \"<cmd>lua require'dap'.disconnect()<cr>\", \"Disconnect\" },\n      e = { \"<cmd>lua require'dapui'.eval()<cr>\", \"Evaluate\" },\n      g = { \"<cmd>lua require'dap'.session()<cr>\", \"Get Session\" },\n      h = { \"<cmd>lua require'dap.ui.widgets'.hover()<cr>\", \"Hover Variables\" },\n      S = { \"<cmd>lua require'dap.ui.widgets'.scopes()<cr>\", \"Scopes\" },\n      i = { \"<cmd>lua require'dap'.step_into()<cr>\", \"Step Into\" },\n      o = { \"<cmd>lua require'dap'.step_over()<cr>\", \"Step Over\" },\n      p = { \"<cmd>lua require'dap'.pause.toggle()<cr>\", \"Pause\" },\n      q = { \"<cmd>lua require'dap'.close()<cr>\", \"Quit\" },\n      r = { \"<cmd>lua require'dap'.repl.toggle()<cr>\", \"Toggle Repl\" },\n      s = { \"<cmd>lua require'dap'.continue()<cr>\", \"Start\" },\n      t = { \"<cmd>lua require'dap'.toggle_breakpoint()<cr>\", \"Toggle Breakpoint\" },\n      x = { \"<cmd>lua require'dap'.terminate()<cr>\", \"Terminate\" },\n      u = { \"<cmd>lua require'dap'.step_out()<cr>\", \"Step Out\" },\n    },\n  }\n  local opts = {\n    mode = \"n\",\n    prefix = \"<leader>\",\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  }\n  whichkey.register(keymap, opts)\n  --- require(\"legendary.integrations.which-key\").bind_whichkey(keymap, opts, false)\n  vim.api.nvim_create_autocmd(\"FileType\", {\n        pattern = \"cpp\",\n        callback = function()\n            vim.api.nvim_buf_set_keymap(\n                0,\n                \"n\",\n                \"<F5>\",\n                \":w<CR>:split<CR>:te g++ % -g -DONLINE_JUDGE -std=c++14 -O2 -o %:t:r -fsanitize=address -fsanitize=undefined<CR>i\",\n                { silent = true, noremap = true }\n            )\n        end,\n    })\n  \n  local keymap_v = {\n    l = {\n      name = \"Debug\",\n      e = { \"<cmd>lua require'dapui'.eval()<cr>\", \"Evaluate\" },\n    },\n  }\n  opts = {\n    mode = \"v\",\n    prefix = \"<leader>\",\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  }\n  whichkey.register(keymap_v, opts)\n  --- require(\"legendary.integrations.which-key\").bind_whichkey(keymap_v, opts, false)\nend\n\nreturn M\n```\n\ndap/ui.lua\n\n```lua\nlocal M={}\nfunction M.setup()\n\trequire(\"nvim-dap-virtual-text\").setup({\n\t\tcommented = true,\n\t})\n\n\tlocal dap, dapui = require(\"dap\"), require(\"dapui\")\n\tdapui.setup({\n\t\texpand_lines = true,\n\t\ticons = { expanded = \"\", collapsed = \"\", circular = \"\" },\n\t\tmappings = {\n\t\t\t-- Use a table to apply multiple mappings\n\t\t\texpand = { \"<CR>\", \"<2-LeftMouse>\" },\n\t\t\topen = \"o\",\n\t\t\tremove = \"d\",\n\t\t\tedit = \"e\",\n\t\t\trepl = \"r\",\n\t\t\ttoggle = \"t\",\n\t\t},\n\t\tlayouts = {\n\t\t\t{\n\t\t\t\telements = {\n\t\t\t\t\t{ id = \"scopes\", size = 0.33 },\n\t\t\t\t\t{ id = \"breakpoints\", size = 0.17 },\n\t\t\t\t\t{ id = \"stacks\", size = 0.25 },\n\t\t\t\t\t{ id = \"watches\", size = 0.25 },\n\t\t\t\t},\n\t\t\t\tsize = 0.33,\n\t\t\t\tposition = \"right\",\n\t\t\t},\n\t\t\t{\n\t\t\t\telements = {\n\t\t\t\t\t{ id = \"repl\", size = 0.45 },\n\t\t\t\t\t{ id = \"console\", size = 0.55 },\n\t\t\t\t},\n\t\t\t\tsize = 0.27,\n\t\t\t\tposition = \"bottom\",\n\t\t\t},\n\t\t},\n\t\tfloating = {\n\t\t\tmax_height = 0.9,\n\t\t\tmax_width = 0.5, -- Floats will be treated as percentage of your screen.\n\t\t\tborder = vim.g.border_chars, -- Border style. Can be 'single', 'double' or 'rounded'\n\t\t\tmappings = {\n\t\t\t\tclose = { \"q\", \"<Esc>\" },\n\t\t\t},\n\t\t},\n\t}) -- use default\n\tdap.listeners.after.event_initialized[\"dapui_config\"] = function()\n\t\tdapui.open({})\n\tend\n\tdap.listeners.before.event_terminated[\"dapui_config\"] = function()\n\t\tdapui.close({})\n\tend\n\tdap.listeners.before.event_exited[\"dapui_config\"] = function()\n\t\tdapui.close({})\n\tend\nend\nreturn M\n```\n\n看得懂的可以自行修改其他地方，\n\n但是你们都要改一个地方就是 `dap/init.lua` 里面那个路径，改成 `OpenDebugAD7` 的位置。\n\n另外 `keymap`里面 有一个 `F5` 的地方，下面是编译命令，可以自行修改。\n\n再回到`configs` 下的那个 `init.lua` 就是加了一堆插件的那个，最下面加上\n\n```lua\nrequire(\"plugins.configs.dap.init\").setup()\n```\n\n## 使用简介\n\n还是建议和 Vscode 一样用一个文件夹，因为我们的 NTR 设置，所以需要和 Vscode 一样建立 `.vscode` 文件夹，里面之用 `launch.json` 即可，里面的 `launch.json` 不能用中文注释，`preTasks` 那项要删掉，然后就可以开用了。\n\n提供一个 `launch.json` 模板，直接就能用：[Link](https://www.luogu.com.cn/paste/teshpofs)\n\n打开一个 C++ 文件，普通模式下按下 `F5` 就可以编译，`Space+l` 可以查看调试可以用的命令，`Space+l+c` 开始调试。看得出来和 Vscode 的调试比较像。\n","source":"_posts/0009.md","raw":"---\ntitle: 浅谈OIer的NVIM配置\ndate: 2023-08-23\ntags: [OI,Nvim,IDE]\ntoc: true\nmathjax: true\n---\n\n# 浅谈OIer的NVIM配置\n\n\n本文因跨平台、软件版本更新等不可控因素，部分内容可能失效，请联系我修改！\n\n## 懒者专用\n\n不建议直接使用！因为路径产生的 BUG 可能很多！\n\n我的配置文件仓库：[wxt1221-NvChad](https://github.com/wxt1221/wxt1221-NvChad)\n\n\n## 前言\n\n某某人在机房配好 Vscode 之后发现卡死了，所以准备用 vim 写代码！\n\n但是网上资料太少了，特别是针对 OIer 刷题的配置，所以我就来了。\n\n上效果图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fd9wcynp.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z81xs7cv.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hymt7myx.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gsvsinza.png)\n\n## 软件选择\n\n原版 Vim 其实并不好，主要有几点。\n\n- 众所周知开屏有些敏感话题\n  \n- 不好配\n  \n\n不过，Vim 的分支多得很，看了一圈决定是 Nvim！\n\n## 安装\n\nLinux 下的话到你自己发行版的库里面找找就是了。\n\nWindows的话有 qnvim，也就是基于 Qt 的。\n\n## 配置\n\nNvim 打开还是和 Vim 差不多，但是真正好用的是网上打包好的配置文件！\n\n隆重推荐 NvChad！（在 github 上有超 1w 的 star）\n\n[NvChad/NvChad](https://github.com/NvChad/NvChad)\n\n安装很简单，在本项目的官网上有详细介绍不同平台的方法\n\n[Link](https://nvchad.com/docs/quickstart/install)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hjq5ehv8.png)\n\n另外还有字体的问题，建议使用带 Nerd 字样的字体，~~我用的是 JetBrains Mono Nerd Font ，应该是没有问题的~~，~~不要用这个字体，Nerd Font 不全，FiraCode 和 JetBrains Mono 风格差不多~~，都有bug！烦死了！，可以先安装 JetBrains Mono 字体，再安装这个：[Link](https://github.com/wangrunlin/nerd-font-JetBrains-windows)，至于怎么换，这个在各个平台上不同，大概率都是你的终端的配置文件里面可以改。\n\n## Vim相关\n\nVim 和普通的文本编辑器有很大不同，Vim 的宗旨之一就是能在不碰鼠标的情况下实现很多功能，为了能够容下更多操作，所以 Vim 其实是有模式区分的。\n\n最常用的是普通模式，在这个模式下可以通过输入冒号进入命令模式。\n\n还有编辑模式，这个模式顾名思义就是可以编辑文件，按 esc 退出到普通模式。\n\n命令模式就是输入命令的，这个是 Vim 单独的一套命令，不是 bash，同样是按 esc 退出到普通模式。\n\n## 常用快捷键\n\n[Neovim的常见快捷键和命令 - 掘金](https://juejin.cn/post/7084462939595341831)\n\n可以参考这篇。\n\n主要是要记住窗口相关的和 tree 相关的。\n\n## 继续配置\n\n然而你发现 NvChad 不能编译运行调试，好难受，~~马上回到 Vscode~~。\n\n其实是可以的，运行和调试是一个东西，所以先说。\n\n调试依赖于 DAP。\n\nNvim 上最好用的 DAP 就是 nvim-dap ，经过了很久的折腾后，终于找到了方法！\n\n要装一堆插件，进入配置文件夹，Linux在`~/.config/nvim` ，Windows在`$HOME\\AppData\\Local\\nvim` ，里面有一个 `lua` 文件夹打开，进入 `plugins` 文件夹 ，打开 `init.lua` 开始编辑。\n\n这个文件是 Nvim 的包管理器，注意到定义了一个 `default_plugins` 直接在这里面改就行了，加入这些插件：\n\n```\n  {\"nvim-telescope/telescope.nvim\",lazy=false},\n  {\"ravenxrz/DAPInstall.nvim\",lazy=false},\n  {\"mfussenegger/nvim-dap\",lazy=false},\n  {\"rcarriga/nvim-dap-ui\",lazy=false},\n  {\"theHamsta/nvim-dap-virtual-text\",lazy=false},\n```\n\n然后退出重进，不出意外就开始下包了。\n\n这里有一个非常 NTR 的事情，就是我们又要用 Vscode 的东西了，这次使用 Vscode 的调试工具！\n\n按冒号进入命令行模式开始安装\n\n```\n:DIInstall ccppr_vsc\n```\n\n就开始跑命令安装了，等到出现了类似于`Process exited` 的字样就说明成功了。\n\n还没结束，接下来才是真正的极客！\n\n在之前打开过的 `plugins` 文件夹里面有一个 `configs`文件夹，建立新文件夹 `dap` 用于写配置文件\n\n`dap/icon.lua`\n\n```lua\nlocal M={}\nfunction M.setup()\n\tlocal dap_breakpoint = {\n\t\tbreakpoint = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignError\",\n\t\t\tlinehl = \"\",\n\t\t\tnumhl = \"\",\n\t\t},\n\t\trejected = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignHint\",\n\t\t\tlinehl = \"\",\n\t\t\tnumhl = \"\",\n\t\t},\n\t\tstopped = {\n\t\t\ttext = \"\",\n\t\t\ttexthl = \"LspDiagnosticsSignInformation\",\n\t\t\tlinehl = \"DiagnosticUnderlineInfo\",\n\t\t\tnumhl = \"LspDiagnosticsSignInformation\",\n\t\t},\n\t}\n\n\tvim.fn.sign_define(\"DapBreakpoint\", dap_breakpoint.breakpoint)\n\tvim.fn.sign_define(\"DapStopped\", dap_breakpoint.stopped)\n\tvim.fn.sign_define(\"DapBreakpointRejected\", dap_breakpoint.rejected)\nend\nreturn M\n```\n\ndap/init.lua\n\n```lua\nlocal M = {}\n\nlocal function configure()\nend\n\nlocal function configure_exts()\nend\n\nlocal function configure_debuggers()\nend\n\nfunction M.setup()\n\tconfigure() -- Configuration\n\tconfigure_exts() -- Extensions\n\tconfigure_debuggers() -- Debugger\n  require(\"plugins.configs.dap.keymap\").setup()\n  require(\"plugins.configs.dap.ui\").setup()\n  require(\"plugins.configs.dap.icon\").setup()\n  require(\"dap.ext.vscode\").load_launchjs(nil, { cppdbg = { \"c\", \"cpp\", \"rust\" } })\n  local dap = require('dap')\n  dap.adapters.cppdbg = {\n    id = 'cppdbg',\n    type = 'executable',\n    command = '/home/wxt/.local/share/nvim/dapinstall/ccppr_vsc/extension/debugAdapters/bin/OpenDebugAD7',\n  }\nend\n\nconfigure_debuggers()\n\nreturn M\n```\n\ndap/keymap.lua\n\n```lua\nlocal M = {}\n\nlocal whichkey = require \"which-key\"\n-- local legendary = require \"legendary\"\n\n-- local function keymap(lhs, rhs, desc)\n--   vim.keymap.set(\"n\", lhs, rhs, { silent = true, desc = desc })\n-- end\n\nfunction M.setup()\n  local keymap = {\n    l = {\n      name = \"DAP\",\n      R = { \"<cmd>lua require'dap'.run_to_cursor()<cr>\", \"Run to Cursor\" },\n      E = { \"<cmd>lua require'dapui'.eval(vim.fn.input '[Expression] > ')<cr>\", \"Evaluate Input\" },\n      C = { \"<cmd>lua require'dap'.set_breakpoint(vim.fn.input '[Condition] > ')<cr>\", \"Conditional Breakpoint\" },\n      U = { \"<cmd>lua require'dapui'.toggle()<cr>\", \"Toggle UI\" },\n      b = { \"<cmd>lua require'dap'.step_back()<cr>\", \"Step Back\" },\n      c = { \"<cmd>lua require'dap'.continue()<cr>\", \"Continue\" },\n      d = { \"<cmd>lua require'dap'.disconnect()<cr>\", \"Disconnect\" },\n      e = { \"<cmd>lua require'dapui'.eval()<cr>\", \"Evaluate\" },\n      g = { \"<cmd>lua require'dap'.session()<cr>\", \"Get Session\" },\n      h = { \"<cmd>lua require'dap.ui.widgets'.hover()<cr>\", \"Hover Variables\" },\n      S = { \"<cmd>lua require'dap.ui.widgets'.scopes()<cr>\", \"Scopes\" },\n      i = { \"<cmd>lua require'dap'.step_into()<cr>\", \"Step Into\" },\n      o = { \"<cmd>lua require'dap'.step_over()<cr>\", \"Step Over\" },\n      p = { \"<cmd>lua require'dap'.pause.toggle()<cr>\", \"Pause\" },\n      q = { \"<cmd>lua require'dap'.close()<cr>\", \"Quit\" },\n      r = { \"<cmd>lua require'dap'.repl.toggle()<cr>\", \"Toggle Repl\" },\n      s = { \"<cmd>lua require'dap'.continue()<cr>\", \"Start\" },\n      t = { \"<cmd>lua require'dap'.toggle_breakpoint()<cr>\", \"Toggle Breakpoint\" },\n      x = { \"<cmd>lua require'dap'.terminate()<cr>\", \"Terminate\" },\n      u = { \"<cmd>lua require'dap'.step_out()<cr>\", \"Step Out\" },\n    },\n  }\n  local opts = {\n    mode = \"n\",\n    prefix = \"<leader>\",\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  }\n  whichkey.register(keymap, opts)\n  --- require(\"legendary.integrations.which-key\").bind_whichkey(keymap, opts, false)\n  vim.api.nvim_create_autocmd(\"FileType\", {\n        pattern = \"cpp\",\n        callback = function()\n            vim.api.nvim_buf_set_keymap(\n                0,\n                \"n\",\n                \"<F5>\",\n                \":w<CR>:split<CR>:te g++ % -g -DONLINE_JUDGE -std=c++14 -O2 -o %:t:r -fsanitize=address -fsanitize=undefined<CR>i\",\n                { silent = true, noremap = true }\n            )\n        end,\n    })\n  \n  local keymap_v = {\n    l = {\n      name = \"Debug\",\n      e = { \"<cmd>lua require'dapui'.eval()<cr>\", \"Evaluate\" },\n    },\n  }\n  opts = {\n    mode = \"v\",\n    prefix = \"<leader>\",\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  }\n  whichkey.register(keymap_v, opts)\n  --- require(\"legendary.integrations.which-key\").bind_whichkey(keymap_v, opts, false)\nend\n\nreturn M\n```\n\ndap/ui.lua\n\n```lua\nlocal M={}\nfunction M.setup()\n\trequire(\"nvim-dap-virtual-text\").setup({\n\t\tcommented = true,\n\t})\n\n\tlocal dap, dapui = require(\"dap\"), require(\"dapui\")\n\tdapui.setup({\n\t\texpand_lines = true,\n\t\ticons = { expanded = \"\", collapsed = \"\", circular = \"\" },\n\t\tmappings = {\n\t\t\t-- Use a table to apply multiple mappings\n\t\t\texpand = { \"<CR>\", \"<2-LeftMouse>\" },\n\t\t\topen = \"o\",\n\t\t\tremove = \"d\",\n\t\t\tedit = \"e\",\n\t\t\trepl = \"r\",\n\t\t\ttoggle = \"t\",\n\t\t},\n\t\tlayouts = {\n\t\t\t{\n\t\t\t\telements = {\n\t\t\t\t\t{ id = \"scopes\", size = 0.33 },\n\t\t\t\t\t{ id = \"breakpoints\", size = 0.17 },\n\t\t\t\t\t{ id = \"stacks\", size = 0.25 },\n\t\t\t\t\t{ id = \"watches\", size = 0.25 },\n\t\t\t\t},\n\t\t\t\tsize = 0.33,\n\t\t\t\tposition = \"right\",\n\t\t\t},\n\t\t\t{\n\t\t\t\telements = {\n\t\t\t\t\t{ id = \"repl\", size = 0.45 },\n\t\t\t\t\t{ id = \"console\", size = 0.55 },\n\t\t\t\t},\n\t\t\t\tsize = 0.27,\n\t\t\t\tposition = \"bottom\",\n\t\t\t},\n\t\t},\n\t\tfloating = {\n\t\t\tmax_height = 0.9,\n\t\t\tmax_width = 0.5, -- Floats will be treated as percentage of your screen.\n\t\t\tborder = vim.g.border_chars, -- Border style. Can be 'single', 'double' or 'rounded'\n\t\t\tmappings = {\n\t\t\t\tclose = { \"q\", \"<Esc>\" },\n\t\t\t},\n\t\t},\n\t}) -- use default\n\tdap.listeners.after.event_initialized[\"dapui_config\"] = function()\n\t\tdapui.open({})\n\tend\n\tdap.listeners.before.event_terminated[\"dapui_config\"] = function()\n\t\tdapui.close({})\n\tend\n\tdap.listeners.before.event_exited[\"dapui_config\"] = function()\n\t\tdapui.close({})\n\tend\nend\nreturn M\n```\n\n看得懂的可以自行修改其他地方，\n\n但是你们都要改一个地方就是 `dap/init.lua` 里面那个路径，改成 `OpenDebugAD7` 的位置。\n\n另外 `keymap`里面 有一个 `F5` 的地方，下面是编译命令，可以自行修改。\n\n再回到`configs` 下的那个 `init.lua` 就是加了一堆插件的那个，最下面加上\n\n```lua\nrequire(\"plugins.configs.dap.init\").setup()\n```\n\n## 使用简介\n\n还是建议和 Vscode 一样用一个文件夹，因为我们的 NTR 设置，所以需要和 Vscode 一样建立 `.vscode` 文件夹，里面之用 `launch.json` 即可，里面的 `launch.json` 不能用中文注释，`preTasks` 那项要删掉，然后就可以开用了。\n\n提供一个 `launch.json` 模板，直接就能用：[Link](https://www.luogu.com.cn/paste/teshpofs)\n\n打开一个 C++ 文件，普通模式下按下 `F5` 就可以编译，`Space+l` 可以查看调试可以用的命令，`Space+l+c` 开始调试。看得出来和 Vscode 的调试比较像。\n","slug":"0009","published":1,"updated":"2024-01-08T11:20:28.866Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65ts000brqaybuj04lwv","content":"<h1 id=\"浅谈OIer的NVIM配置\"><a href=\"#浅谈OIer的NVIM配置\" class=\"headerlink\" title=\"浅谈OIer的NVIM配置\"></a>浅谈OIer的NVIM配置</h1><p>本文因跨平台、软件版本更新等不可控因素，部分内容可能失效，请联系我修改！</p>\n<h2 id=\"懒者专用\"><a href=\"#懒者专用\" class=\"headerlink\" title=\"懒者专用\"></a>懒者专用</h2><p>不建议直接使用！因为路径产生的 BUG 可能很多！</p>\n<p>我的配置文件仓库：<a href=\"https://github.com/wxt1221/wxt1221-NvChad\">wxt1221-NvChad</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>某某人在机房配好 Vscode 之后发现卡死了，所以准备用 vim 写代码！</p>\n<p>但是网上资料太少了，特别是针对 OIer 刷题的配置，所以我就来了。</p>\n<p>上效果图：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/fd9wcynp.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/z81xs7cv.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/hymt7myx.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/gsvsinza.png\" alt=\"\"></p>\n<h2 id=\"软件选择\"><a href=\"#软件选择\" class=\"headerlink\" title=\"软件选择\"></a>软件选择</h2><p>原版 Vim 其实并不好，主要有几点。</p>\n<ul>\n<li><p>众所周知开屏有些敏感话题</p>\n</li>\n<li><p>不好配</p>\n</li>\n</ul>\n<p>不过，Vim 的分支多得很，看了一圈决定是 Nvim！</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Linux 下的话到你自己发行版的库里面找找就是了。</p>\n<p>Windows的话有 qnvim，也就是基于 Qt 的。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Nvim 打开还是和 Vim 差不多，但是真正好用的是网上打包好的配置文件！</p>\n<p>隆重推荐 NvChad！（在 github 上有超 1w 的 star）</p>\n<p><a href=\"https://github.com/NvChad/NvChad\">NvChad/NvChad</a></p>\n<p>安装很简单，在本项目的官网上有详细介绍不同平台的方法</p>\n<p><a href=\"https://nvchad.com/docs/quickstart/install\">Link</a></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/hjq5ehv8.png\" alt=\"\"></p>\n<p>另外还有字体的问题，建议使用带 Nerd 字样的字体，<del>我用的是 JetBrains Mono Nerd Font ，应该是没有问题的</del>，<del>不要用这个字体，Nerd Font 不全，FiraCode 和 JetBrains Mono 风格差不多</del>，都有bug！烦死了！，可以先安装 JetBrains Mono 字体，再安装这个：<a href=\"https://github.com/wangrunlin/nerd-font-JetBrains-windows\">Link</a>，至于怎么换，这个在各个平台上不同，大概率都是你的终端的配置文件里面可以改。</p>\n<h2 id=\"Vim相关\"><a href=\"#Vim相关\" class=\"headerlink\" title=\"Vim相关\"></a>Vim相关</h2><p>Vim 和普通的文本编辑器有很大不同，Vim 的宗旨之一就是能在不碰鼠标的情况下实现很多功能，为了能够容下更多操作，所以 Vim 其实是有模式区分的。</p>\n<p>最常用的是普通模式，在这个模式下可以通过输入冒号进入命令模式。</p>\n<p>还有编辑模式，这个模式顾名思义就是可以编辑文件，按 esc 退出到普通模式。</p>\n<p>命令模式就是输入命令的，这个是 Vim 单独的一套命令，不是 bash，同样是按 esc 退出到普通模式。</p>\n<h2 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h2><p><a href=\"https://juejin.cn/post/7084462939595341831\">Neovim的常见快捷键和命令 - 掘金</a></p>\n<p>可以参考这篇。</p>\n<p>主要是要记住窗口相关的和 tree 相关的。</p>\n<h2 id=\"继续配置\"><a href=\"#继续配置\" class=\"headerlink\" title=\"继续配置\"></a>继续配置</h2><p>然而你发现 NvChad 不能编译运行调试，好难受，<del>马上回到 Vscode</del>。</p>\n<p>其实是可以的，运行和调试是一个东西，所以先说。</p>\n<p>调试依赖于 DAP。</p>\n<p>Nvim 上最好用的 DAP 就是 nvim-dap ，经过了很久的折腾后，终于找到了方法！</p>\n<p>要装一堆插件，进入配置文件夹，Linux在<code>~/.config/nvim</code> ，Windows在<code>$HOME\\AppData\\Local\\nvim</code> ，里面有一个 <code>lua</code> 文件夹打开，进入 <code>plugins</code> 文件夹 ，打开 <code>init.lua</code> 开始编辑。</p>\n<p>这个文件是 Nvim 的包管理器，注意到定义了一个 <code>default_plugins</code> 直接在这里面改就行了，加入这些插件：</p>\n<pre><code>  &#123;&quot;nvim-telescope/telescope.nvim&quot;,lazy=false&#125;,\n  &#123;&quot;ravenxrz/DAPInstall.nvim&quot;,lazy=false&#125;,\n  &#123;&quot;mfussenegger/nvim-dap&quot;,lazy=false&#125;,\n  &#123;&quot;rcarriga/nvim-dap-ui&quot;,lazy=false&#125;,\n  &#123;&quot;theHamsta/nvim-dap-virtual-text&quot;,lazy=false&#125;,\n</code></pre><p>然后退出重进，不出意外就开始下包了。</p>\n<p>这里有一个非常 NTR 的事情，就是我们又要用 Vscode 的东西了，这次使用 Vscode 的调试工具！</p>\n<p>按冒号进入命令行模式开始安装</p>\n<pre><code>:DIInstall ccppr_vsc\n</code></pre><p>就开始跑命令安装了，等到出现了类似于<code>Process exited</code> 的字样就说明成功了。</p>\n<p>还没结束，接下来才是真正的极客！</p>\n<p>在之前打开过的 <code>plugins</code> 文件夹里面有一个 <code>configs</code>文件夹，建立新文件夹 <code>dap</code> 用于写配置文件</p>\n<p><code>dap/icon.lua</code></p>\n<pre><code class=\"lang-lua\">local M=&#123;&#125;\nfunction M.setup()\n    local dap_breakpoint = &#123;\n        breakpoint = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignError&quot;,\n            linehl = &quot;&quot;,\n            numhl = &quot;&quot;,\n        &#125;,\n        rejected = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignHint&quot;,\n            linehl = &quot;&quot;,\n            numhl = &quot;&quot;,\n        &#125;,\n        stopped = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignInformation&quot;,\n            linehl = &quot;DiagnosticUnderlineInfo&quot;,\n            numhl = &quot;LspDiagnosticsSignInformation&quot;,\n        &#125;,\n    &#125;\n\n    vim.fn.sign_define(&quot;DapBreakpoint&quot;, dap_breakpoint.breakpoint)\n    vim.fn.sign_define(&quot;DapStopped&quot;, dap_breakpoint.stopped)\n    vim.fn.sign_define(&quot;DapBreakpointRejected&quot;, dap_breakpoint.rejected)\nend\nreturn M\n</code></pre>\n<p>dap/init.lua</p>\n<pre><code class=\"lang-lua\">local M = &#123;&#125;\n\nlocal function configure()\nend\n\nlocal function configure_exts()\nend\n\nlocal function configure_debuggers()\nend\n\nfunction M.setup()\n    configure() -- Configuration\n    configure_exts() -- Extensions\n    configure_debuggers() -- Debugger\n  require(&quot;plugins.configs.dap.keymap&quot;).setup()\n  require(&quot;plugins.configs.dap.ui&quot;).setup()\n  require(&quot;plugins.configs.dap.icon&quot;).setup()\n  require(&quot;dap.ext.vscode&quot;).load_launchjs(nil, &#123; cppdbg = &#123; &quot;c&quot;, &quot;cpp&quot;, &quot;rust&quot; &#125; &#125;)\n  local dap = require(&#39;dap&#39;)\n  dap.adapters.cppdbg = &#123;\n    id = &#39;cppdbg&#39;,\n    type = &#39;executable&#39;,\n    command = &#39;/home/wxt/.local/share/nvim/dapinstall/ccppr_vsc/extension/debugAdapters/bin/OpenDebugAD7&#39;,\n  &#125;\nend\n\nconfigure_debuggers()\n\nreturn M\n</code></pre>\n<p>dap/keymap.lua</p>\n<pre><code class=\"lang-lua\">local M = &#123;&#125;\n\nlocal whichkey = require &quot;which-key&quot;\n-- local legendary = require &quot;legendary&quot;\n\n-- local function keymap(lhs, rhs, desc)\n--   vim.keymap.set(&quot;n&quot;, lhs, rhs, &#123; silent = true, desc = desc &#125;)\n-- end\n\nfunction M.setup()\n  local keymap = &#123;\n    l = &#123;\n      name = &quot;DAP&quot;,\n      R = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.run_to_cursor()&lt;cr&gt;&quot;, &quot;Run to Cursor&quot; &#125;,\n      E = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval(vim.fn.input &#39;[Expression] &gt; &#39;)&lt;cr&gt;&quot;, &quot;Evaluate Input&quot; &#125;,\n      C = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.set_breakpoint(vim.fn.input &#39;[Condition] &gt; &#39;)&lt;cr&gt;&quot;, &quot;Conditional Breakpoint&quot; &#125;,\n      U = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.toggle()&lt;cr&gt;&quot;, &quot;Toggle UI&quot; &#125;,\n      b = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_back()&lt;cr&gt;&quot;, &quot;Step Back&quot; &#125;,\n      c = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.continue()&lt;cr&gt;&quot;, &quot;Continue&quot; &#125;,\n      d = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.disconnect()&lt;cr&gt;&quot;, &quot;Disconnect&quot; &#125;,\n      e = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval()&lt;cr&gt;&quot;, &quot;Evaluate&quot; &#125;,\n      g = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.session()&lt;cr&gt;&quot;, &quot;Get Session&quot; &#125;,\n      h = &#123; &quot;&lt;cmd&gt;lua require&#39;dap.ui.widgets&#39;.hover()&lt;cr&gt;&quot;, &quot;Hover Variables&quot; &#125;,\n      S = &#123; &quot;&lt;cmd&gt;lua require&#39;dap.ui.widgets&#39;.scopes()&lt;cr&gt;&quot;, &quot;Scopes&quot; &#125;,\n      i = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_into()&lt;cr&gt;&quot;, &quot;Step Into&quot; &#125;,\n      o = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_over()&lt;cr&gt;&quot;, &quot;Step Over&quot; &#125;,\n      p = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.pause.toggle()&lt;cr&gt;&quot;, &quot;Pause&quot; &#125;,\n      q = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.close()&lt;cr&gt;&quot;, &quot;Quit&quot; &#125;,\n      r = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.repl.toggle()&lt;cr&gt;&quot;, &quot;Toggle Repl&quot; &#125;,\n      s = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.continue()&lt;cr&gt;&quot;, &quot;Start&quot; &#125;,\n      t = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.toggle_breakpoint()&lt;cr&gt;&quot;, &quot;Toggle Breakpoint&quot; &#125;,\n      x = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.terminate()&lt;cr&gt;&quot;, &quot;Terminate&quot; &#125;,\n      u = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_out()&lt;cr&gt;&quot;, &quot;Step Out&quot; &#125;,\n    &#125;,\n  &#125;\n  local opts = &#123;\n    mode = &quot;n&quot;,\n    prefix = &quot;&lt;leader&gt;&quot;,\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  &#125;\n  whichkey.register(keymap, opts)\n  --- require(&quot;legendary.integrations.which-key&quot;).bind_whichkey(keymap, opts, false)\n  vim.api.nvim_create_autocmd(&quot;FileType&quot;, &#123;\n        pattern = &quot;cpp&quot;,\n        callback = function()\n            vim.api.nvim_buf_set_keymap(\n                0,\n                &quot;n&quot;,\n                &quot;&lt;F5&gt;&quot;,\n                &quot;:w&lt;CR&gt;:split&lt;CR&gt;:te g++ % -g -DONLINE_JUDGE -std=c++14 -O2 -o %:t:r -fsanitize=address -fsanitize=undefined&lt;CR&gt;i&quot;,\n                &#123; silent = true, noremap = true &#125;\n            )\n        end,\n    &#125;)\n\n  local keymap_v = &#123;\n    l = &#123;\n      name = &quot;Debug&quot;,\n      e = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval()&lt;cr&gt;&quot;, &quot;Evaluate&quot; &#125;,\n    &#125;,\n  &#125;\n  opts = &#123;\n    mode = &quot;v&quot;,\n    prefix = &quot;&lt;leader&gt;&quot;,\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  &#125;\n  whichkey.register(keymap_v, opts)\n  --- require(&quot;legendary.integrations.which-key&quot;).bind_whichkey(keymap_v, opts, false)\nend\n\nreturn M\n</code></pre>\n<p>dap/ui.lua</p>\n<pre><code class=\"lang-lua\">local M=&#123;&#125;\nfunction M.setup()\n    require(&quot;nvim-dap-virtual-text&quot;).setup(&#123;\n        commented = true,\n    &#125;)\n\n    local dap, dapui = require(&quot;dap&quot;), require(&quot;dapui&quot;)\n    dapui.setup(&#123;\n        expand_lines = true,\n        icons = &#123; expanded = &quot;&quot;, collapsed = &quot;&quot;, circular = &quot;&quot; &#125;,\n        mappings = &#123;\n            -- Use a table to apply multiple mappings\n            expand = &#123; &quot;&lt;CR&gt;&quot;, &quot;&lt;2-LeftMouse&gt;&quot; &#125;,\n            open = &quot;o&quot;,\n            remove = &quot;d&quot;,\n            edit = &quot;e&quot;,\n            repl = &quot;r&quot;,\n            toggle = &quot;t&quot;,\n        &#125;,\n        layouts = &#123;\n            &#123;\n                elements = &#123;\n                    &#123; id = &quot;scopes&quot;, size = 0.33 &#125;,\n                    &#123; id = &quot;breakpoints&quot;, size = 0.17 &#125;,\n                    &#123; id = &quot;stacks&quot;, size = 0.25 &#125;,\n                    &#123; id = &quot;watches&quot;, size = 0.25 &#125;,\n                &#125;,\n                size = 0.33,\n                position = &quot;right&quot;,\n            &#125;,\n            &#123;\n                elements = &#123;\n                    &#123; id = &quot;repl&quot;, size = 0.45 &#125;,\n                    &#123; id = &quot;console&quot;, size = 0.55 &#125;,\n                &#125;,\n                size = 0.27,\n                position = &quot;bottom&quot;,\n            &#125;,\n        &#125;,\n        floating = &#123;\n            max_height = 0.9,\n            max_width = 0.5, -- Floats will be treated as percentage of your screen.\n            border = vim.g.border_chars, -- Border style. Can be &#39;single&#39;, &#39;double&#39; or &#39;rounded&#39;\n            mappings = &#123;\n                close = &#123; &quot;q&quot;, &quot;&lt;Esc&gt;&quot; &#125;,\n            &#125;,\n        &#125;,\n    &#125;) -- use default\n    dap.listeners.after.event_initialized[&quot;dapui_config&quot;] = function()\n        dapui.open(&#123;&#125;)\n    end\n    dap.listeners.before.event_terminated[&quot;dapui_config&quot;] = function()\n        dapui.close(&#123;&#125;)\n    end\n    dap.listeners.before.event_exited[&quot;dapui_config&quot;] = function()\n        dapui.close(&#123;&#125;)\n    end\nend\nreturn M\n</code></pre>\n<p>看得懂的可以自行修改其他地方，</p>\n<p>但是你们都要改一个地方就是 <code>dap/init.lua</code> 里面那个路径，改成 <code>OpenDebugAD7</code> 的位置。</p>\n<p>另外 <code>keymap</code>里面 有一个 <code>F5</code> 的地方，下面是编译命令，可以自行修改。</p>\n<p>再回到<code>configs</code> 下的那个 <code>init.lua</code> 就是加了一堆插件的那个，最下面加上</p>\n<pre><code class=\"lang-lua\">require(&quot;plugins.configs.dap.init&quot;).setup()\n</code></pre>\n<h2 id=\"使用简介\"><a href=\"#使用简介\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h2><p>还是建议和 Vscode 一样用一个文件夹，因为我们的 NTR 设置，所以需要和 Vscode 一样建立 <code>.vscode</code> 文件夹，里面之用 <code>launch.json</code> 即可，里面的 <code>launch.json</code> 不能用中文注释，<code>preTasks</code> 那项要删掉，然后就可以开用了。</p>\n<p>提供一个 <code>launch.json</code> 模板，直接就能用：<a href=\"https://www.luogu.com.cn/paste/teshpofs\">Link</a></p>\n<p>打开一个 C++ 文件，普通模式下按下 <code>F5</code> 就可以编译，<code>Space+l</code> 可以查看调试可以用的命令，<code>Space+l+c</code> 开始调试。看得出来和 Vscode 的调试比较像。</p>\n","excerpt":"","more":"<h1 id=\"浅谈OIer的NVIM配置\"><a href=\"#浅谈OIer的NVIM配置\" class=\"headerlink\" title=\"浅谈OIer的NVIM配置\"></a>浅谈OIer的NVIM配置</h1><p>本文因跨平台、软件版本更新等不可控因素，部分内容可能失效，请联系我修改！</p>\n<h2 id=\"懒者专用\"><a href=\"#懒者专用\" class=\"headerlink\" title=\"懒者专用\"></a>懒者专用</h2><p>不建议直接使用！因为路径产生的 BUG 可能很多！</p>\n<p>我的配置文件仓库：<a href=\"https://github.com/wxt1221/wxt1221-NvChad\">wxt1221-NvChad</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>某某人在机房配好 Vscode 之后发现卡死了，所以准备用 vim 写代码！</p>\n<p>但是网上资料太少了，特别是针对 OIer 刷题的配置，所以我就来了。</p>\n<p>上效果图：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/fd9wcynp.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/z81xs7cv.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/hymt7myx.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/gsvsinza.png\" alt=\"\"></p>\n<h2 id=\"软件选择\"><a href=\"#软件选择\" class=\"headerlink\" title=\"软件选择\"></a>软件选择</h2><p>原版 Vim 其实并不好，主要有几点。</p>\n<ul>\n<li><p>众所周知开屏有些敏感话题</p>\n</li>\n<li><p>不好配</p>\n</li>\n</ul>\n<p>不过，Vim 的分支多得很，看了一圈决定是 Nvim！</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Linux 下的话到你自己发行版的库里面找找就是了。</p>\n<p>Windows的话有 qnvim，也就是基于 Qt 的。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Nvim 打开还是和 Vim 差不多，但是真正好用的是网上打包好的配置文件！</p>\n<p>隆重推荐 NvChad！（在 github 上有超 1w 的 star）</p>\n<p><a href=\"https://github.com/NvChad/NvChad\">NvChad/NvChad</a></p>\n<p>安装很简单，在本项目的官网上有详细介绍不同平台的方法</p>\n<p><a href=\"https://nvchad.com/docs/quickstart/install\">Link</a></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/hjq5ehv8.png\" alt=\"\"></p>\n<p>另外还有字体的问题，建议使用带 Nerd 字样的字体，<del>我用的是 JetBrains Mono Nerd Font ，应该是没有问题的</del>，<del>不要用这个字体，Nerd Font 不全，FiraCode 和 JetBrains Mono 风格差不多</del>，都有bug！烦死了！，可以先安装 JetBrains Mono 字体，再安装这个：<a href=\"https://github.com/wangrunlin/nerd-font-JetBrains-windows\">Link</a>，至于怎么换，这个在各个平台上不同，大概率都是你的终端的配置文件里面可以改。</p>\n<h2 id=\"Vim相关\"><a href=\"#Vim相关\" class=\"headerlink\" title=\"Vim相关\"></a>Vim相关</h2><p>Vim 和普通的文本编辑器有很大不同，Vim 的宗旨之一就是能在不碰鼠标的情况下实现很多功能，为了能够容下更多操作，所以 Vim 其实是有模式区分的。</p>\n<p>最常用的是普通模式，在这个模式下可以通过输入冒号进入命令模式。</p>\n<p>还有编辑模式，这个模式顾名思义就是可以编辑文件，按 esc 退出到普通模式。</p>\n<p>命令模式就是输入命令的，这个是 Vim 单独的一套命令，不是 bash，同样是按 esc 退出到普通模式。</p>\n<h2 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h2><p><a href=\"https://juejin.cn/post/7084462939595341831\">Neovim的常见快捷键和命令 - 掘金</a></p>\n<p>可以参考这篇。</p>\n<p>主要是要记住窗口相关的和 tree 相关的。</p>\n<h2 id=\"继续配置\"><a href=\"#继续配置\" class=\"headerlink\" title=\"继续配置\"></a>继续配置</h2><p>然而你发现 NvChad 不能编译运行调试，好难受，<del>马上回到 Vscode</del>。</p>\n<p>其实是可以的，运行和调试是一个东西，所以先说。</p>\n<p>调试依赖于 DAP。</p>\n<p>Nvim 上最好用的 DAP 就是 nvim-dap ，经过了很久的折腾后，终于找到了方法！</p>\n<p>要装一堆插件，进入配置文件夹，Linux在<code>~/.config/nvim</code> ，Windows在<code>$HOME\\AppData\\Local\\nvim</code> ，里面有一个 <code>lua</code> 文件夹打开，进入 <code>plugins</code> 文件夹 ，打开 <code>init.lua</code> 开始编辑。</p>\n<p>这个文件是 Nvim 的包管理器，注意到定义了一个 <code>default_plugins</code> 直接在这里面改就行了，加入这些插件：</p>\n<pre><code>  &#123;&quot;nvim-telescope/telescope.nvim&quot;,lazy=false&#125;,\n  &#123;&quot;ravenxrz/DAPInstall.nvim&quot;,lazy=false&#125;,\n  &#123;&quot;mfussenegger/nvim-dap&quot;,lazy=false&#125;,\n  &#123;&quot;rcarriga/nvim-dap-ui&quot;,lazy=false&#125;,\n  &#123;&quot;theHamsta/nvim-dap-virtual-text&quot;,lazy=false&#125;,\n</code></pre><p>然后退出重进，不出意外就开始下包了。</p>\n<p>这里有一个非常 NTR 的事情，就是我们又要用 Vscode 的东西了，这次使用 Vscode 的调试工具！</p>\n<p>按冒号进入命令行模式开始安装</p>\n<pre><code>:DIInstall ccppr_vsc\n</code></pre><p>就开始跑命令安装了，等到出现了类似于<code>Process exited</code> 的字样就说明成功了。</p>\n<p>还没结束，接下来才是真正的极客！</p>\n<p>在之前打开过的 <code>plugins</code> 文件夹里面有一个 <code>configs</code>文件夹，建立新文件夹 <code>dap</code> 用于写配置文件</p>\n<p><code>dap/icon.lua</code></p>\n<pre><code class=\"lang-lua\">local M=&#123;&#125;\nfunction M.setup()\n    local dap_breakpoint = &#123;\n        breakpoint = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignError&quot;,\n            linehl = &quot;&quot;,\n            numhl = &quot;&quot;,\n        &#125;,\n        rejected = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignHint&quot;,\n            linehl = &quot;&quot;,\n            numhl = &quot;&quot;,\n        &#125;,\n        stopped = &#123;\n            text = &quot;&quot;,\n            texthl = &quot;LspDiagnosticsSignInformation&quot;,\n            linehl = &quot;DiagnosticUnderlineInfo&quot;,\n            numhl = &quot;LspDiagnosticsSignInformation&quot;,\n        &#125;,\n    &#125;\n\n    vim.fn.sign_define(&quot;DapBreakpoint&quot;, dap_breakpoint.breakpoint)\n    vim.fn.sign_define(&quot;DapStopped&quot;, dap_breakpoint.stopped)\n    vim.fn.sign_define(&quot;DapBreakpointRejected&quot;, dap_breakpoint.rejected)\nend\nreturn M\n</code></pre>\n<p>dap/init.lua</p>\n<pre><code class=\"lang-lua\">local M = &#123;&#125;\n\nlocal function configure()\nend\n\nlocal function configure_exts()\nend\n\nlocal function configure_debuggers()\nend\n\nfunction M.setup()\n    configure() -- Configuration\n    configure_exts() -- Extensions\n    configure_debuggers() -- Debugger\n  require(&quot;plugins.configs.dap.keymap&quot;).setup()\n  require(&quot;plugins.configs.dap.ui&quot;).setup()\n  require(&quot;plugins.configs.dap.icon&quot;).setup()\n  require(&quot;dap.ext.vscode&quot;).load_launchjs(nil, &#123; cppdbg = &#123; &quot;c&quot;, &quot;cpp&quot;, &quot;rust&quot; &#125; &#125;)\n  local dap = require(&#39;dap&#39;)\n  dap.adapters.cppdbg = &#123;\n    id = &#39;cppdbg&#39;,\n    type = &#39;executable&#39;,\n    command = &#39;/home/wxt/.local/share/nvim/dapinstall/ccppr_vsc/extension/debugAdapters/bin/OpenDebugAD7&#39;,\n  &#125;\nend\n\nconfigure_debuggers()\n\nreturn M\n</code></pre>\n<p>dap/keymap.lua</p>\n<pre><code class=\"lang-lua\">local M = &#123;&#125;\n\nlocal whichkey = require &quot;which-key&quot;\n-- local legendary = require &quot;legendary&quot;\n\n-- local function keymap(lhs, rhs, desc)\n--   vim.keymap.set(&quot;n&quot;, lhs, rhs, &#123; silent = true, desc = desc &#125;)\n-- end\n\nfunction M.setup()\n  local keymap = &#123;\n    l = &#123;\n      name = &quot;DAP&quot;,\n      R = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.run_to_cursor()&lt;cr&gt;&quot;, &quot;Run to Cursor&quot; &#125;,\n      E = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval(vim.fn.input &#39;[Expression] &gt; &#39;)&lt;cr&gt;&quot;, &quot;Evaluate Input&quot; &#125;,\n      C = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.set_breakpoint(vim.fn.input &#39;[Condition] &gt; &#39;)&lt;cr&gt;&quot;, &quot;Conditional Breakpoint&quot; &#125;,\n      U = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.toggle()&lt;cr&gt;&quot;, &quot;Toggle UI&quot; &#125;,\n      b = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_back()&lt;cr&gt;&quot;, &quot;Step Back&quot; &#125;,\n      c = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.continue()&lt;cr&gt;&quot;, &quot;Continue&quot; &#125;,\n      d = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.disconnect()&lt;cr&gt;&quot;, &quot;Disconnect&quot; &#125;,\n      e = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval()&lt;cr&gt;&quot;, &quot;Evaluate&quot; &#125;,\n      g = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.session()&lt;cr&gt;&quot;, &quot;Get Session&quot; &#125;,\n      h = &#123; &quot;&lt;cmd&gt;lua require&#39;dap.ui.widgets&#39;.hover()&lt;cr&gt;&quot;, &quot;Hover Variables&quot; &#125;,\n      S = &#123; &quot;&lt;cmd&gt;lua require&#39;dap.ui.widgets&#39;.scopes()&lt;cr&gt;&quot;, &quot;Scopes&quot; &#125;,\n      i = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_into()&lt;cr&gt;&quot;, &quot;Step Into&quot; &#125;,\n      o = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_over()&lt;cr&gt;&quot;, &quot;Step Over&quot; &#125;,\n      p = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.pause.toggle()&lt;cr&gt;&quot;, &quot;Pause&quot; &#125;,\n      q = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.close()&lt;cr&gt;&quot;, &quot;Quit&quot; &#125;,\n      r = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.repl.toggle()&lt;cr&gt;&quot;, &quot;Toggle Repl&quot; &#125;,\n      s = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.continue()&lt;cr&gt;&quot;, &quot;Start&quot; &#125;,\n      t = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.toggle_breakpoint()&lt;cr&gt;&quot;, &quot;Toggle Breakpoint&quot; &#125;,\n      x = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.terminate()&lt;cr&gt;&quot;, &quot;Terminate&quot; &#125;,\n      u = &#123; &quot;&lt;cmd&gt;lua require&#39;dap&#39;.step_out()&lt;cr&gt;&quot;, &quot;Step Out&quot; &#125;,\n    &#125;,\n  &#125;\n  local opts = &#123;\n    mode = &quot;n&quot;,\n    prefix = &quot;&lt;leader&gt;&quot;,\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  &#125;\n  whichkey.register(keymap, opts)\n  --- require(&quot;legendary.integrations.which-key&quot;).bind_whichkey(keymap, opts, false)\n  vim.api.nvim_create_autocmd(&quot;FileType&quot;, &#123;\n        pattern = &quot;cpp&quot;,\n        callback = function()\n            vim.api.nvim_buf_set_keymap(\n                0,\n                &quot;n&quot;,\n                &quot;&lt;F5&gt;&quot;,\n                &quot;:w&lt;CR&gt;:split&lt;CR&gt;:te g++ % -g -DONLINE_JUDGE -std=c++14 -O2 -o %:t:r -fsanitize=address -fsanitize=undefined&lt;CR&gt;i&quot;,\n                &#123; silent = true, noremap = true &#125;\n            )\n        end,\n    &#125;)\n\n  local keymap_v = &#123;\n    l = &#123;\n      name = &quot;Debug&quot;,\n      e = &#123; &quot;&lt;cmd&gt;lua require&#39;dapui&#39;.eval()&lt;cr&gt;&quot;, &quot;Evaluate&quot; &#125;,\n    &#125;,\n  &#125;\n  opts = &#123;\n    mode = &quot;v&quot;,\n    prefix = &quot;&lt;leader&gt;&quot;,\n    buffer = nil,\n    silent = true,\n    noremap = true,\n    nowait = false,\n  &#125;\n  whichkey.register(keymap_v, opts)\n  --- require(&quot;legendary.integrations.which-key&quot;).bind_whichkey(keymap_v, opts, false)\nend\n\nreturn M\n</code></pre>\n<p>dap/ui.lua</p>\n<pre><code class=\"lang-lua\">local M=&#123;&#125;\nfunction M.setup()\n    require(&quot;nvim-dap-virtual-text&quot;).setup(&#123;\n        commented = true,\n    &#125;)\n\n    local dap, dapui = require(&quot;dap&quot;), require(&quot;dapui&quot;)\n    dapui.setup(&#123;\n        expand_lines = true,\n        icons = &#123; expanded = &quot;&quot;, collapsed = &quot;&quot;, circular = &quot;&quot; &#125;,\n        mappings = &#123;\n            -- Use a table to apply multiple mappings\n            expand = &#123; &quot;&lt;CR&gt;&quot;, &quot;&lt;2-LeftMouse&gt;&quot; &#125;,\n            open = &quot;o&quot;,\n            remove = &quot;d&quot;,\n            edit = &quot;e&quot;,\n            repl = &quot;r&quot;,\n            toggle = &quot;t&quot;,\n        &#125;,\n        layouts = &#123;\n            &#123;\n                elements = &#123;\n                    &#123; id = &quot;scopes&quot;, size = 0.33 &#125;,\n                    &#123; id = &quot;breakpoints&quot;, size = 0.17 &#125;,\n                    &#123; id = &quot;stacks&quot;, size = 0.25 &#125;,\n                    &#123; id = &quot;watches&quot;, size = 0.25 &#125;,\n                &#125;,\n                size = 0.33,\n                position = &quot;right&quot;,\n            &#125;,\n            &#123;\n                elements = &#123;\n                    &#123; id = &quot;repl&quot;, size = 0.45 &#125;,\n                    &#123; id = &quot;console&quot;, size = 0.55 &#125;,\n                &#125;,\n                size = 0.27,\n                position = &quot;bottom&quot;,\n            &#125;,\n        &#125;,\n        floating = &#123;\n            max_height = 0.9,\n            max_width = 0.5, -- Floats will be treated as percentage of your screen.\n            border = vim.g.border_chars, -- Border style. Can be &#39;single&#39;, &#39;double&#39; or &#39;rounded&#39;\n            mappings = &#123;\n                close = &#123; &quot;q&quot;, &quot;&lt;Esc&gt;&quot; &#125;,\n            &#125;,\n        &#125;,\n    &#125;) -- use default\n    dap.listeners.after.event_initialized[&quot;dapui_config&quot;] = function()\n        dapui.open(&#123;&#125;)\n    end\n    dap.listeners.before.event_terminated[&quot;dapui_config&quot;] = function()\n        dapui.close(&#123;&#125;)\n    end\n    dap.listeners.before.event_exited[&quot;dapui_config&quot;] = function()\n        dapui.close(&#123;&#125;)\n    end\nend\nreturn M\n</code></pre>\n<p>看得懂的可以自行修改其他地方，</p>\n<p>但是你们都要改一个地方就是 <code>dap/init.lua</code> 里面那个路径，改成 <code>OpenDebugAD7</code> 的位置。</p>\n<p>另外 <code>keymap</code>里面 有一个 <code>F5</code> 的地方，下面是编译命令，可以自行修改。</p>\n<p>再回到<code>configs</code> 下的那个 <code>init.lua</code> 就是加了一堆插件的那个，最下面加上</p>\n<pre><code class=\"lang-lua\">require(&quot;plugins.configs.dap.init&quot;).setup()\n</code></pre>\n<h2 id=\"使用简介\"><a href=\"#使用简介\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h2><p>还是建议和 Vscode 一样用一个文件夹，因为我们的 NTR 设置，所以需要和 Vscode 一样建立 <code>.vscode</code> 文件夹，里面之用 <code>launch.json</code> 即可，里面的 <code>launch.json</code> 不能用中文注释，<code>preTasks</code> 那项要删掉，然后就可以开用了。</p>\n<p>提供一个 <code>launch.json</code> 模板，直接就能用：<a href=\"https://www.luogu.com.cn/paste/teshpofs\">Link</a></p>\n<p>打开一个 C++ 文件，普通模式下按下 <code>F5</code> 就可以编译，<code>Space+l</code> 可以查看调试可以用的命令，<code>Space+l+c</code> 开始调试。看得出来和 Vscode 的调试比较像。</p>\n"},{"title":"CF449B","date":"2024-01-02T16:00:00.000Z","toc":true,"mathjax":true,"_content":"\n## 题目简述\n\n有一张边带权的无向图，边分成两种，第一种无特殊限制，第二种边有一个端点在 $1$ 号节点，问至多可以删多少条边可以使原图从 $1$ 到所有点的最短路长度不变。\n\n## 分析\n\n很容易注意到需要跑单源最短路，由于题目中要求的是使最短路不变的情况，所以考虑是否可以在最短路过程中 DP 转移下功夫，很明显需要优先从第一种边转移，于是在转移的过程中注意一下转移过去的值相等时如何更新即可，因为最短路的转移过程没有后效性，所以这样转移是正确的。\n\n最后统计没有进行 DP 转移的边的数量即可。\n\n## 代码实现\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define int long long\ninline int read();\nint fir[100005];\nint nxt[800005];\nint v[800005];\nint w[800005];\nint knd[800005];\nint now=0;\nbool vised[100005];\nclass node{\n    public:\n        int x,y;\n        node(int xx,int yy){\n            x=xx;\n            y=yy;\n        }\n};\nbool operator < (node a,node b){\n    return a.y>b.y;\n}\nstd::priority_queue<node>qu;\nint from[100005];\nint dp[100005];\nint used[800005];\nvoid add(int xx,int yy,int zz,int kk){\n    now++;\n    knd[now]=kk;\n    v[now]=yy;\n    w[now]=zz;\n    nxt[now]=fir[xx];\n    fir[xx]=now;\n    return ;\n}\nsigned main(){\n\t#ifdef ONLINE_JUDGE\n\t#else\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n\t#endif\n    int n=read(),m,k;\n    m=read();\n    k=read();\n    for(int i=1;i<=n;i++){\n        fir[i]=-1;\n        dp[i]=0x3f3f3f3f3f3f3f3fll;\n    }\n    for(int i=1;i<=m;i++){\n        int xx=read(),yy,zz;\n        yy=read();\n        zz=read();\n        add(xx,yy,zz,0);\n        add(yy,xx,zz,0);\n    }\n    for(int i=1;i<=k;i++){\n        int s=read();\n        int y=read();\n        add(1,s,y,1);\n        add(s,1,y,1);\n    }\n    dp[1]=0;\n    qu.push(node(1,0));\n    while(qu.size()>0){\n        node noww=qu.top();\n        qu.pop();\n        int now=noww.x;\n        if(vised[now]){\n            continue;\n        }\n        vised[now]=1;\n        for(int i=fir[now];i!=-1;i=nxt[i]){\n            if(dp[now]+w[i]<dp[v[i]]){\n                dp[v[i]]=dp[now]+w[i];\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n                if(!vised[v[i]])\n                    qu.push(node(v[i],dp[v[i]]));\n            }else if(dp[now]+w[i]==dp[v[i]]&&knd[from[v[i]]]==1){\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=m*2+1;i<=m*2+k*2;i+=2){\n        if(!used[i]&&!used[i+1]){\n            ans++;\n        }\n    }\n    printf(\"%lld\",ans);\n\treturn 0;\n}\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tc=='-'?f=-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n\t1:\n\t\tIn:\n\n\t\tOut:\nMore:\n\n*/\n\n```\n","source":"_posts/0010.md","raw":"---\ntitle: CF449B\ndate: 2024-01-03\ntags: [OI,网络流]\ntoc: true\nmathjax: true\n---\n\n## 题目简述\n\n有一张边带权的无向图，边分成两种，第一种无特殊限制，第二种边有一个端点在 $1$ 号节点，问至多可以删多少条边可以使原图从 $1$ 到所有点的最短路长度不变。\n\n## 分析\n\n很容易注意到需要跑单源最短路，由于题目中要求的是使最短路不变的情况，所以考虑是否可以在最短路过程中 DP 转移下功夫，很明显需要优先从第一种边转移，于是在转移的过程中注意一下转移过去的值相等时如何更新即可，因为最短路的转移过程没有后效性，所以这样转移是正确的。\n\n最后统计没有进行 DP 转移的边的数量即可。\n\n## 代码实现\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define int long long\ninline int read();\nint fir[100005];\nint nxt[800005];\nint v[800005];\nint w[800005];\nint knd[800005];\nint now=0;\nbool vised[100005];\nclass node{\n    public:\n        int x,y;\n        node(int xx,int yy){\n            x=xx;\n            y=yy;\n        }\n};\nbool operator < (node a,node b){\n    return a.y>b.y;\n}\nstd::priority_queue<node>qu;\nint from[100005];\nint dp[100005];\nint used[800005];\nvoid add(int xx,int yy,int zz,int kk){\n    now++;\n    knd[now]=kk;\n    v[now]=yy;\n    w[now]=zz;\n    nxt[now]=fir[xx];\n    fir[xx]=now;\n    return ;\n}\nsigned main(){\n\t#ifdef ONLINE_JUDGE\n\t#else\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n\t#endif\n    int n=read(),m,k;\n    m=read();\n    k=read();\n    for(int i=1;i<=n;i++){\n        fir[i]=-1;\n        dp[i]=0x3f3f3f3f3f3f3f3fll;\n    }\n    for(int i=1;i<=m;i++){\n        int xx=read(),yy,zz;\n        yy=read();\n        zz=read();\n        add(xx,yy,zz,0);\n        add(yy,xx,zz,0);\n    }\n    for(int i=1;i<=k;i++){\n        int s=read();\n        int y=read();\n        add(1,s,y,1);\n        add(s,1,y,1);\n    }\n    dp[1]=0;\n    qu.push(node(1,0));\n    while(qu.size()>0){\n        node noww=qu.top();\n        qu.pop();\n        int now=noww.x;\n        if(vised[now]){\n            continue;\n        }\n        vised[now]=1;\n        for(int i=fir[now];i!=-1;i=nxt[i]){\n            if(dp[now]+w[i]<dp[v[i]]){\n                dp[v[i]]=dp[now]+w[i];\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n                if(!vised[v[i]])\n                    qu.push(node(v[i],dp[v[i]]));\n            }else if(dp[now]+w[i]==dp[v[i]]&&knd[from[v[i]]]==1){\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=m*2+1;i<=m*2+k*2;i+=2){\n        if(!used[i]&&!used[i+1]){\n            ans++;\n        }\n    }\n    printf(\"%lld\",ans);\n\treturn 0;\n}\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tc=='-'?f=-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n\t1:\n\t\tIn:\n\n\t\tOut:\nMore:\n\n*/\n\n```\n","slug":"0010","published":1,"updated":"2024-01-08T11:21:06.007Z","comments":1,"layout":"post","photos":[],"_id":"clr4u65u8000erqaycqqhhu5o","content":"<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>有一张边带权的无向图，边分成两种，第一种无特殊限制，第二种边有一个端点在 $1$ 号节点，问至多可以删多少条边可以使原图从 $1$ 到所有点的最短路长度不变。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>很容易注意到需要跑单源最短路，由于题目中要求的是使最短路不变的情况，所以考虑是否可以在最短路过程中 DP 转移下功夫，很明显需要优先从第一种边转移，于是在转移的过程中注意一下转移过去的值相等时如何更新即可，因为最短路的转移过程没有后效性，所以这样转移是正确的。</p>\n<p>最后统计没有进行 DP 转移的边的数量即可。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;queue&gt;\n#define int long long\ninline int read();\nint fir[100005];\nint nxt[800005];\nint v[800005];\nint w[800005];\nint knd[800005];\nint now=0;\nbool vised[100005];\nclass node&#123;\n    public:\n        int x,y;\n        node(int xx,int yy)&#123;\n            x=xx;\n            y=yy;\n        &#125;\n&#125;;\nbool operator &lt; (node a,node b)&#123;\n    return a.y&gt;b.y;\n&#125;\nstd::priority_queue&lt;node&gt;qu;\nint from[100005];\nint dp[100005];\nint used[800005];\nvoid add(int xx,int yy,int zz,int kk)&#123;\n    now++;\n    knd[now]=kk;\n    v[now]=yy;\n    w[now]=zz;\n    nxt[now]=fir[xx];\n    fir[xx]=now;\n    return ;\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE\n    #else\n    freopen(&quot;.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),m,k;\n    m=read();\n    k=read();\n    for(int i=1;i&lt;=n;i++)&#123;\n        fir[i]=-1;\n        dp[i]=0x3f3f3f3f3f3f3f3fll;\n    &#125;\n    for(int i=1;i&lt;=m;i++)&#123;\n        int xx=read(),yy,zz;\n        yy=read();\n        zz=read();\n        add(xx,yy,zz,0);\n        add(yy,xx,zz,0);\n    &#125;\n    for(int i=1;i&lt;=k;i++)&#123;\n        int s=read();\n        int y=read();\n        add(1,s,y,1);\n        add(s,1,y,1);\n    &#125;\n    dp[1]=0;\n    qu.push(node(1,0));\n    while(qu.size()&gt;0)&#123;\n        node noww=qu.top();\n        qu.pop();\n        int now=noww.x;\n        if(vised[now])&#123;\n            continue;\n        &#125;\n        vised[now]=1;\n        for(int i=fir[now];i!=-1;i=nxt[i])&#123;\n            if(dp[now]+w[i]&lt;dp[v[i]])&#123;\n                dp[v[i]]=dp[now]+w[i];\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n                if(!vised[v[i]])\n                    qu.push(node(v[i],dp[v[i]]));\n            &#125;else if(dp[now]+w[i]==dp[v[i]]&amp;&amp;knd[from[v[i]]]==1)&#123;\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n            &#125;\n        &#125;\n    &#125;\n    int ans=0;\n    for(int i=m*2+1;i&lt;=m*2+k*2;i+=2)&#123;\n        if(!used[i]&amp;&amp;!used[i+1])&#123;\n            ans++;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;,ans);\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n","excerpt":"","more":"<h2 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h2><p>有一张边带权的无向图，边分成两种，第一种无特殊限制，第二种边有一个端点在 $1$ 号节点，问至多可以删多少条边可以使原图从 $1$ 到所有点的最短路长度不变。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>很容易注意到需要跑单源最短路，由于题目中要求的是使最短路不变的情况，所以考虑是否可以在最短路过程中 DP 转移下功夫，很明显需要优先从第一种边转移，于是在转移的过程中注意一下转移过去的值相等时如何更新即可，因为最短路的转移过程没有后效性，所以这样转移是正确的。</p>\n<p>最后统计没有进行 DP 转移的边的数量即可。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"lang-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;queue&gt;\n#define int long long\ninline int read();\nint fir[100005];\nint nxt[800005];\nint v[800005];\nint w[800005];\nint knd[800005];\nint now=0;\nbool vised[100005];\nclass node&#123;\n    public:\n        int x,y;\n        node(int xx,int yy)&#123;\n            x=xx;\n            y=yy;\n        &#125;\n&#125;;\nbool operator &lt; (node a,node b)&#123;\n    return a.y&gt;b.y;\n&#125;\nstd::priority_queue&lt;node&gt;qu;\nint from[100005];\nint dp[100005];\nint used[800005];\nvoid add(int xx,int yy,int zz,int kk)&#123;\n    now++;\n    knd[now]=kk;\n    v[now]=yy;\n    w[now]=zz;\n    nxt[now]=fir[xx];\n    fir[xx]=now;\n    return ;\n&#125;\nsigned main()&#123;\n    #ifdef ONLINE_JUDGE\n    #else\n    freopen(&quot;.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;.out&quot;,&quot;w&quot;,stdout);\n    #endif\n    int n=read(),m,k;\n    m=read();\n    k=read();\n    for(int i=1;i&lt;=n;i++)&#123;\n        fir[i]=-1;\n        dp[i]=0x3f3f3f3f3f3f3f3fll;\n    &#125;\n    for(int i=1;i&lt;=m;i++)&#123;\n        int xx=read(),yy,zz;\n        yy=read();\n        zz=read();\n        add(xx,yy,zz,0);\n        add(yy,xx,zz,0);\n    &#125;\n    for(int i=1;i&lt;=k;i++)&#123;\n        int s=read();\n        int y=read();\n        add(1,s,y,1);\n        add(s,1,y,1);\n    &#125;\n    dp[1]=0;\n    qu.push(node(1,0));\n    while(qu.size()&gt;0)&#123;\n        node noww=qu.top();\n        qu.pop();\n        int now=noww.x;\n        if(vised[now])&#123;\n            continue;\n        &#125;\n        vised[now]=1;\n        for(int i=fir[now];i!=-1;i=nxt[i])&#123;\n            if(dp[now]+w[i]&lt;dp[v[i]])&#123;\n                dp[v[i]]=dp[now]+w[i];\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n                if(!vised[v[i]])\n                    qu.push(node(v[i],dp[v[i]]));\n            &#125;else if(dp[now]+w[i]==dp[v[i]]&amp;&amp;knd[from[v[i]]]==1)&#123;\n                used[from[v[i]]]=0;\n                used[i]=1;\n                from[v[i]]=i;\n            &#125;\n        &#125;\n    &#125;\n    int ans=0;\n    for(int i=m*2+1;i&lt;=m*2+k*2;i+=2)&#123;\n        if(!used[i]&amp;&amp;!used[i+1])&#123;\n            ans++;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;,ans);\n    return 0;\n&#125;\ninline int read()&#123;\n    int x=0,f=1;char c=getchar();\n    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)&#123;\n        c==&#39;-&#39;?f=-1:1;\n        c=getchar();\n    &#125;\n    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);\n        c=getchar();\n    &#125;\n    return f*x;\n&#125;\n/*\nAnything about this program:\nType:\n\nDescription:\n\nExample:\n    1:\n        In:\n\n        Out:\nMore:\n\n*/\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clr4u65tq000arqaydgpdejjd","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65u0000drqayashs4xv9"},{"post_id":"clr4u65ps0000rqay1rcb8b79","tag_id":"clr4u65rp0002rqayckfma1t7","_id":"clr4u65un000frqay60a23yin"},{"post_id":"clr4u65ps0000rqay1rcb8b79","tag_id":"clr4u65t60006rqaygy7j5z1c","_id":"clr4u65uu000hrqayczzg8ck7"},{"post_id":"clr4u65ps0000rqay1rcb8b79","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65uu000irqaye4lz152e"},{"post_id":"clr4u65r20001rqay89mf16r3","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65v2000lrqay5tx6gfat"},{"post_id":"clr4u65r20001rqay89mf16r3","tag_id":"clr4u65ut000grqayecejgvm2","_id":"clr4u65v2000mrqay6os91go2"},{"post_id":"clr4u65r20001rqay89mf16r3","tag_id":"clr4u65uv000jrqay6czjdq2f","_id":"clr4u65v3000orqay6bfuagll"},{"post_id":"clr4u65sa0003rqaygts84jim","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65v4000qrqay37rjetm6"},{"post_id":"clr4u65sa0003rqaygts84jim","tag_id":"clr4u65v2000nrqay0ko17mje","_id":"clr4u65v8000rrqay1asf4334"},{"post_id":"clr4u65sg0004rqayaaf1fdec","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65va000trqay8edg4stb"},{"post_id":"clr4u65t40005rqay3vibh0rj","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65vc000wrqay2nd0fb4k"},{"post_id":"clr4u65t40005rqay3vibh0rj","tag_id":"clr4u65va000urqayayoxdzlw","_id":"clr4u65vc000xrqayeuta79q0"},{"post_id":"clr4u65tf0007rqayfv44fmei","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65vd000zrqaybmma665w"},{"post_id":"clr4u65th0008rqay3lqugmln","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65vj0012rqayhgh45anv"},{"post_id":"clr4u65th0008rqay3lqugmln","tag_id":"clr4u65ve0010rqay67eu11b3","_id":"clr4u65vk0013rqay02cb5ag2"},{"post_id":"clr4u65ts000brqaybuj04lwv","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65vt0016rqay3iqp8s4v"},{"post_id":"clr4u65ts000brqaybuj04lwv","tag_id":"clr4u65vi0011rqaygafi93n3","_id":"clr4u65vu0017rqayhlgmge06"},{"post_id":"clr4u65ts000brqaybuj04lwv","tag_id":"clr4u65vk0014rqayhe3l80f2","_id":"clr4u65vu0018rqaybkbt3xcd"},{"post_id":"clr4u65u8000erqaycqqhhu5o","tag_id":"clr4u65to0009rqay52rxd32w","_id":"clr4u65vv0019rqayaid68rxy"},{"post_id":"clr4u65u8000erqaycqqhhu5o","tag_id":"clr4u65ve0010rqay67eu11b3","_id":"clr4u65vv001arqayas809l61"}],"Tag":[{"name":"数据结构","_id":"clr4u65rp0002rqayckfma1t7"},{"name":"并查集","_id":"clr4u65t60006rqaygy7j5z1c"},{"name":"OI","_id":"clr4u65to0009rqay52rxd32w"},{"name":"树形结构","_id":"clr4u65ut000grqayecejgvm2"},{"name":"分治","_id":"clr4u65uv000jrqay6czjdq2f"},{"name":"多项式","_id":"clr4u65v2000nrqay0ko17mje"},{"name":"NOI_Linux","_id":"clr4u65va000urqayayoxdzlw"},{"name":"网络流","_id":"clr4u65ve0010rqay67eu11b3"},{"name":"Nvim","_id":"clr4u65vi0011rqaygafi93n3"},{"name":"IDE","_id":"clr4u65vk0014rqayhe3l80f2"}]}}